@ !UCDebug, ARM debugger for RISC OS.
@ https://github.com/fuentesp/UCDebug
@ Copyright (C) 2018  University of Cantabria
@
@ !UCDebug was developed by the Computer Architecture and Technology
@ Group at the University of Cantabria. A comprehensive list of authors
@ can be found in the file AUTHORS.txt.
@
@ You can reach the main developers at {fernando.vallejo, cristobal.camarero,
@ pablo.fuentes}@unican.es.
@
@ This program is free software: you can redistribute it and/or modify
@ it under the terms of the GNU General Public License as published by
@ the Free Software Foundation, either version 3 of the License, or
@ (at your option) any later version.
@
@ This program is distributed in the hope that it will be useful,
@ but WITHOUT ANY WARRANTY; without even the implied warranty of
@ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@ GNU General Public License for more details.
@
@ You should have received a copy of the GNU General Public License
@ along with this program.  If not, see <https://www.gnu.org/licenses/>.

.global   CodeExecute
.extern   CurContext
.extern   BrkPtList
.extern   CurNumBr
.extern   GTBrkP
.extern   ExecType
.extern	  validMemAddressRange
.global   HandPreRel
.global   HandDatRel
.global   HandUndRel
.global   HandIRQRel
.global   ourregisters
.global   ReturnHandler
.global   StackHandler
.global   PrefetchAddress
.global   drivercount
.global   drivertable
.global   DbgControllerMask
.global   UsrControllerMask
.global   ControllerBaseAddress

.equ SWI_Mask,    0x0F000000
.equ Cond_Mask,   0xF0000000
.equ Code_OSExit, 0x0F000011
.equ Code_OSWriteStr, 0x0F000002
.equ Code_OSWriteChar, 0x0F000000
.equ Code_OSGetChar, 0x0F000004
.equ Code_OSEnterOS, 0x0F000016
.equ Code_OSLeaveOS, 0x0F00007C
.equ Code_OSClaimDeviceVector, 0x0F00004B
.equ Code_OSReleaseDeviceVector, 0x0F00004C
.equ Num_Loop,    1000
.equ BrkpInst,    0xE1200071


.data

.align 2
ourregisters:  .space 280  @ include CPSR, FPU Regs and usr-specific regs
jumpregisters: .space 64
Loop:          .space  4
HandPreRel:    .space  4
HandDatRel:    .space  4
HandUndRel:    .space  4
HandIRQRel:    .space  4
ReturnHandler: .space  4
StackHandler:  .space  4
PrefetchAddress:	.word 0
PendingGetChar:         .word 0
ControllerBaseAddress:  .word 0

immediatebreakpointnumber: .word 0
immediatebreakpoints: .space 0x80 @16 pairs (address, instruction)

.align 2
drivercount:          .word 0
drivertable:          .space 120	@ 10 simultaneous drivers (device
					@ number, driver address, R12 value)
DbgControllerMask:    .word 0, 0, 0     @ masks for IRQs 1, 2, & basic in the GUI
UsrControllerMask:    .word 0, 0, 0	@ masks for IRQs 1, 2 & basic in the user code

.text

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@ Function called from the C-written interface to execute the code to debug.
@
CodeExecute:

@
@ It stores the debugger context including CPSR
@
sub sp,sp,#4
str r0,[sp]
ldr r0,=ourregisters
stm r0, {r0-r12}  @ storing PC is useless; sp and lr is done per-mode
ldr r1,[sp]
str r1,[r0] @ write program r0 in its place
add sp,sp,#4
mrs r1,CPSR @ write debugger CPSR
str r1,[r0,#64]
swi 0x16 @ OS_EnterOS (enter SVC mode)
str sp, [r0, #200] @ write debugger SVC sp
str lr, [r0, #204] @ write debugger SVC lr
mrs r2, SPSR
str r2, [r0, #208] @ write debugger SVC spsr
mrs r1, cpsr
bic r1, r1, #0x1
msr cpsr, r1 @ switch from SVC to IRQ mode
str sp, [r0, #236] @ write IRQ sp
str lr, [r0, #240] @ write IRQ lr
mrs r2, spsr
str r2, [r0, #244] @ write IRQ SPSR in its place
orr r1, r1, #0x5
msr cpsr, r1 @ switch from IRQ to Abt mode
str sp, [r0, #212] @ write abort sp
str lr, [r0, #216] @ write abort lr
mrs r2, spsr
str r2, [r0, #220] @ write abort SPSR
bic r1, r1, #0x6
msr cpsr, r1 @ switch from Abt to FIQ mode
add r2, r0, #248
stm r2, {r8-r14} @ write FIQ specific regs
mrs r2, spsr
str r2, [r0, #276] @ write FIQ SPSR in its place
orr r1, r1, #0xA
msr cpsr, r1 @ switch from FIQ to Und mode
str sp, [r0, #224] @ write undefined sp
str lr, [r0, #228] @ write undefined lr
mrs r2, spsr
str r2, [r0, #232] @ write undefined SPSR in its place
orr r1, r1, #0x1F
msr cpsr, r1 @ switch to Sys mode
str sp, [r0, #52] @ write user sp
str lr, [r0, #56] @ write user lr

ldr r0, =ControllerBaseAddress
ldr r0, [r0]
add r0, r0, #0x210
ldm r0, {r1-r3}
ldr r0, =DbgControllerMask
stm r0, {r1-r3}			@ Store IRQ enable from GUI


@
@ Number of loops = 0
@
ldr r0,=Loop
mov r1,#0
str r1,[r0]
@
@ It looks if the next instruction has to be executed
@
Another_inst:
bl CheckInst
tst r0, #0xFF00         @ Check State byte of ExecType
bne End_CodeExec
tst r0, #0x10000	@ Instruction is not run, but dbg does not return to GUI
bne checkreturn

@
@ Set Brkpt in the following instruction
@
tst r0, #0xF0
blne setfastbreakpoints		@ set breakpoints for Go-Fast mode
bl setimmediatebreakpoints

@
@ jumptoprogram enables the handler routine for the breakpoint, switches to the context
@ from the debugged program, executes the instruction, stores part of the context from
@ the debugged program (except sp, lr and CPSR) and disables the brkpt handler routine
@
jtp:
bl jumptoprogram

@
@ Remove Breakpoint from the following instruction
@
bl clearimmediatebreakpoints

@
@ Check if the execution goes on; if at the comeback the state byte at r0 is 0, it
@ returns to the CLI
@
checkreturn:
bl ReturnCLI
cmp r0,#0
bne Another_inst

@
@ Recover the context from the debugger, including the CPSR
@
End_CodeExec:
ldr r0,=ourregisters
mrs r1, CPSR
ldr sp, [r0, #200] @ load debugger SVC sp
ldr lr, [r0, #204] @ load debugger SVC lr
ldr r2, [r0, #208]
msr spsr, r2       @ load debugger SVC spsr
bic r1, r1, #0x1
msr cpsr, r1 @ switch from SVC to IRQ mode
ldr sp, [r0, #236] @ load IRQ sp
ldr lr, [r0, #240] @ load IRQ lr
ldr r2, [r0, #244]
msr spsr, r2       @ load IRQ SPSR
orr r1, r1, #0x5
msr cpsr, r1 @ switch from IRQ to Abt mode
ldr sp, [r0, #212] @ load abort sp
ldr lr, [r0, #216] @ load abort lr
ldr r2, [r0, #220]
msr spsr, r2       @ load abort SPSR
bic r1, r1, #0x6
msr cpsr, r1 @ switch from Abt to FIQ mode
add r2, r0, #248
ldm r2, {r8-r14}   @ load FIQ specific regs
ldr r2, [r0, #276]
msr spsr, r2       @ load FIQ SPSR
orr r1, r1, #0xA
msr cpsr, r1 @ switch from FIQ to Und mode
ldr sp, [r0, #224] @ load undefined sp
ldr lr, [r0, #228] @ load undefined lr
ldr r2, [r0, #232]
msr spsr, r2       @ load undefined SPSR
orr r1, r1, #0x1F
msr cpsr, r1 @ switch to Sys mode
add r1, r0, #4
ldm r1, {r1-r14}  @ recover general purpose regs (previous usr mode is unknown)
ldr r1,[r0,#64]  @ CPSR
msr CPSR, r1
ldm r0, {r0-r12}  @ PC is not recovered

mov pc,lr

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@ jumptoprogram enables the handler routine for the breakpoint, switches to the context
@ from the debugged program, executes the instruction, stores part of the context from
@ the debugged program (except sp, lr and CPSR) and disables the brkpt handler routine
@
jumptoprogram:

ldr r0,=ReturnHandler
str lr,[r0]
ldr r0,=StackHandler
str sp,[r0]

bl EnableFPU

ldr r1,=CurContext
ldr r0,[r1,#60]
ldr r0,[r0] @ prefetch the instruction
ldr r0,[r1,#212]
ldr r0,[r0,#-4] @prefetch the data abort stack of the program

@ Prefetch a given address that has caused a page error
ldr r1, =PrefetchAddress
ldr r2, [r1]
cmp r2, #0
beq placeHandlers
ldrb r3, [r2]
mov r3, #0
str r3, [r1]		@ Clear PrefetchAddress

placeHandlers:
mov r0,#0x01 @ claim + UNdefined instruction
orr r0,r0,#0x100
ldr r1,=UndefinedInstructHandler
mov r2,#0
swi 0x69 @ OS_ClaimProcessorVector
@remember to release r1
ldr r0,=HandUndRel
str r1,[r0]

mrs r1, cpsr
orr r1, r1, #0x180	@ Disable imprecise aborts and interrupts
msr cpsr, r1		@ to avoid inconsistent states

mov r0,#0x03 @ claim + prefetch abort
orr r0,r0,#0x100
ldr r1,=PrefetchAbortHandler
mov r2,#0
swi 0x69 @ OS_ClaimProcessorVector
@remember to release r1
ldr r0,=HandPreRel
str r1,[r0]

mov r0,#0x04 @ claim + Data abort
orr r0,r0,#0x100
ldr r1,=DataAbortHandler
mov r2,#0
swi 0x69 @ OS_ClaimProcessorVector
@remember to release r1
ldr r0,=HandDatRel
str r1,[r0]

mov r0, #0x06 	@ claim + IRQ
orr r0, r0, #0x100
ldr r1, =IRQHandler
mov r2, #0
swi 0x69 @ OS_ClaimProcessorVector
ldr r0, =HandIRQRel	@ remember to release r1
str r1, [r0]

@
@ write disable and enable IRQ regs to only allow interrupts
@ in the IRQ table to happen
@
mvn r1, #0			@ Load all bits to 1
mov r2, r1
bic r2, r2, #0x10000		@ Do NOT disable mouse
mov r3, r1
ldr r4, =ControllerBaseAddress
ldr r4, [r4]
add r5, r4, #0x21C
str r1, [r5], #4                @ Disable all interrupts
str r2, [r5], #4		@ one by one (a stm produces weird
str r3, [r5], #4		@ effects)
ldr r0, =UsrControllerMask
ldm r0, {r1-r3}
add r5, r4, #0x210
str r1, [r5], #4		@ Enable those interrupts used by the user
str r2, [r5], #4		@ (also register by register)
str r3, [r5], #4

@
@ Load context from all modes
@ TODO: define sp for all modes, to prevent errors
@
ldr r0,=CurContext
add r1, r0, #68
vldm r1, {s0-s31} @ load floating-point regs
ldr r1, [r1, #128]
vmsr FPSCR, r1 @ load FPSCR
mrs r1, cpsr
bic r1, r1, #0xC
msr cpsr, r1 @ switch from Sys to SVC mode
ldr sp, [r0, #200] @ load svc sp
ldr lr, [r0, #204] @ load svc lr
ldr r2, [r0, #208]
msr spsr, r2 @ load svc SPSR
mrs r1, cpsr
orr r1, r1, #0x4
msr cpsr, r1 @ switch from SVC to Abt mode
ldr sp, [r0, #212] @ load abt sp
ldr lr, [r0, #216] @ load abt lr
ldr r2, [r0, #220]
msr spsr, r2 @ load abt SPSR
bic r1, r1, #0x5
msr cpsr, r1 @ switch from Abt to IRQ mode
ldr sp, [r0, #236] @ load IRQ sp
ldr lr, [r0, #240] @ load IRQ lr
ldr r2, [r0, #244]
msr spsr, r2 @ load IRQ SPSR
orr r1, r1, #0x9
msr cpsr, r1 @ switch from IRQ to Und mode
ldr sp, [r0, #224] @ load Und sp
ldr lr, [r0, #228] @ load Und lr
ldr r2, [r0, #232]
msr spsr, r2 @ load Und SPSR
bic r1, r1, #0xA
msr cpsr, r1 @ switch from Und to FIQ mode
add r2, r0, #248
ldm r2, {r8-r14} @ load FIQ specific regs
ldr r2, [r0, #276]
msr spsr, r2 @ load FIQ SPSR
orr r1, r1, #0x1F
msr cpsr, r1 @ switch to system mode to access remaining user regs
ldr r1, =AuxCurContext
ldm r0, {r2-r4}		@ get user R0-R2
ldr r5, [r0, #60]	@ and user PC
stm r1, {r2-r5}	@ store them away in an aux var
add r2, r0, #8
ldm r2, {r2-r14} @ load regs from usr mode (to update sp and lr, in case
                 @ the user program was left in a different user mode)
ldr r2,[r0,#64]
msr CPSR, r2		@ load usr CPSR
ldm r1, {r0-r2, pc}	@ jump to user program




@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@   Function (CheckInstCond) that determines if the next instruction execution condition
@	is accomplished, depending on the flags of the CPSR. Return 0 for FALSE and
@	1 for TRUE.
CheckInstCond:
stmdb sp!, {r4-r5, lr}
and r2, r1, #0x80000000	@ N flag
and r3, r1, #0x40000000	@ Z flag
and r4, r1, #0x20000000	@ C flag
and r5, r1, #0x10000000	@ V flag

ands r1, r0, #0xE       @ If the 3 highest bits of the cond are 0, it depends
bne condC		@ on the Z flag
condZ:			@ Inst. will run if cond=0 & Z=1, or cond=1 & Z=0
lsr r3, r3, #30
eor r0, r0, r3
b res
condC:
ands r1, r0, #0xC	@ If the 3 highest bits of 'cond' are 001, it depends
bne condN		@ on the C flag
and r1, r0, #1          @ Inst. will run if cond=2 & C=1, or cond=3 & C=0
lsr r4, r4, #29
eor r0, r1, r4
b res
condN:
and r1, r0, #0xE	@ If the 3 highest bits of 'cond' are 010, it depends
cmp r1, #0x4	@ on the N flag
bne condV
and r1, r0, #1		@ Inst. will run if cond=4 & N=1, or cond=5 & N=0
lsr r2, r2, #31
eor r0, r1, r2
b res
condV:
ands r1, r0, #8		@ If the 3 highest bits of 'cond' are 011, it depends
bne condCZ		@ on the V flag
and r1, r0, #1		@ Inst. will run if cond=6 & V=1, or cond=7 & V=0
lsr r5, r5, #28
eor r0, r1, r5
b res
condCZ:
ands r1, r0, #6		@ If the 3 highest bits of 'cond' are 100, it depends
bne condNV		@ on the C and Z flags
lsrs r4, r4, #29	@ Inst. will run if C=1 & Z=0, or cond=9 & C=0
lsr r3, r3, #30
eorne r0, r4, r3
and r1, r0, #1
eoreq r0, r4, r1
b res
condNV:
ands r1, r0, #4		@ If the 3 highest bits of 'cond' are 101, it depends
bne condNVZ		@ on the N and V flags
lsr r2, r2, #31		@ Inst. will run if (bit 0 of cond XOR (N XOR V))=0
lsr r5, r5, #28
eor r2, r2, r5
and r1, r0, #1
eor r1, r1, r2
eor r0, r1, #1
b res
condNVZ:
@ Inst. will run based on eq. (not(Z)not(b0 XOR (N XOR V)) + b0Z, where b0 is the lowest significant bit of 'cond'
lsr r2, r2, #31
lsr r3, r3, #30
lsr r5, r5, #28
and r1, r0, #1
eor r2, r2, r5
eor r2, r1, r2
orr r2, r3, r2
eor r2, r2, #1
and r1, r1, r3
orr r0, r2, r1

res:
ldmia sp!, {r4-r5, pc}

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@   Function (CheckInst) that determines if the next instruction is to be executed. It
@	is not executed if it is one of the following SWIs:
@     - Code_OSExit
@     - Code_OSWriteStr
@     - Code_OSWriteChar
@     - Code_OSGetChar
@     - Code_OSEnterOS
@     - Code_OSLeaveOS
@     - Code_OSClaimDeviceVector
@     - Code_OSReleaseDeviceVector
@   Returns in r0 an ExecType that reports if the instruction will be executed or not.
@
CheckInst:
stmdb sp!, {r4, r5, lr}

ldr r5, =CurContext
ldr r0,[r5,#60]

bl validMemAddressRange	@ before analysing the instruction, check if the address
cmp r0, #0		@ is within the valid range
bne load_instruction	@ valid address, load the instruction
ldr r1,=ExecType
mov r0, #0x1400 	@ mark an Out-of-Range exception, so the instruction is not run
str r0,[r1]
b End_checkinstr

load_instruction:
ldr r0,[r5,#60]
ldr r4,[r0] @ Load the instruction

@ First check if it is a SWI; otherwise, jump to end
and r1, r4, #SWI_Mask
cmp r1, #SWI_Mask
bne End_checkinstr

@ Then check if the exec is inconditional or not
and r1, r4, #Cond_Mask
cmp r1, #0xE0000000
beq checkinstr1	@ Inconditional execution, check if it is one of the captured SWIs

@ Conditional execution, verify if it will execute
lsr r0, r1, #28         @ Load condition field
ldr r1, [r5,#64]	@ Load CPSR
bl CheckInstCond
cmp r0, #0
beq End_checkinstr	@ It the instruction will not be executed, skip checkings

checkinstr1:
bic r4, r4, #Cond_Mask
ldr r1,=Code_OSExit
cmp r4,r1
bne Else_checkinstr1
@ change ExecType
ldr r1,=ExecType
ldr r0,[r1]
add r0, r0, #0x0100
str r0,[r1] @ Change ExecType to Prg_End
b Default_checkinstr

Else_checkinstr1:
ldr r1, =Code_OSWriteStr
cmp r4,r1
bne Else_checkinstr2
@ change ExecType
ldr r1, =ExecType
ldr r0, [r1]
add r0, r0, #0x0300
str r0, [r1]
b Default_checkinstr

Else_checkinstr2:
ldr r1, =Code_OSWriteChar
cmp r4,r1
bne Else_checkinstr3
ldr r1, =ExecType
ldr r0, [r1]
add r0, r0, #0x0200
str r0, [r1]
b Default_checkinstr

Else_checkinstr3:
ldr r1, =Code_OSGetChar
cmp r4, r1
bne Else_checkinstr4
ldr r0, =PendingGetChar
ldr r1, [r0]
cmp r1, #0
bne RunGetChar		@ Check if getChar has been exec'd
str r0, [r0]		@ Store in PendingGetChar its own address: anything non-zero
ldr r1, =ExecType
ldr r0, [r1]
add r0, r0, #0x0600
str r0, [r1]		@ Update ExecType, to ensure it goes to GUI
b End_checkinstr
RunGetChar:
mov r1, #0
str r1, [r0]		@ reset PendingGetChar var
swi 0x4
ldr r1, =CurContext
str r0, [r1]		@ store in r0 from usr context the char read in the SWI
ldr r1, =ExecType
ldr r0, [r1]
add r0, r0, #0x10000	@ Update ExecType: it should skip going to the GUI
str r0, [r1]
b Default_checkinstr

Else_checkinstr4:
ldr r1, =Code_OSEnterOS
cmp r4,r1
bne Else_checkinstr5
ldr r1,[r5,#64]		@ CPSR
str r1,[r5,#208]        @ Store previous CPSR in svc SPSR
bic r1,r1,#0x1F
orr r1,r1,#0x13
str r1,[r5,#64]		@ Update CPSR with the SVC user mode
ldr r1,[r5,#60]
str r1,[r5,#204]        @ Store previous PC in LR
ldr r1, =ExecType
ldr r0, [r1]
add r0, r0, #0x10000	@ Update ExecType: it should skip going to the GUI
str r0, [r1]
b Default_checkinstr

Else_checkinstr5:
ldr r1, =Code_OSLeaveOS
cmp r4,r1
bne Else_checkinstr6
ldr r1,[r5,#64] 	@CPSR
bic r1,r1,#0xF
str r1,[r5,#64]		@Update CPSR with User mode
ldr r1, =ExecType
ldr r0, [r1]
add r0, r0, #0x10000	@ Update ExecType: it should skip going to the GUI
str r0, [r1]
b Default_checkinstr

Else_checkinstr6:
ldr r1, =Code_OSClaimDeviceVector
cmp r4, r1
bne Else_checkinstr7
ldr r0, [r5]		@ Check if the device should be used
cmp r0, #64
bge NotRunClaimDev
@ check if interrupt already in GUI
ldr r1, =DbgControllerMask
cmp r0, #32
addge r1, r1, #4	@ if device>=32, get IRQ 2
ldr r1, [r1]
mov r2, #1
lsl r2, r2, r0		@ translate device number into its bit within mask
tst r1, r2
bne NotRunClaimDev	@ device already in Dbg mask, should not be used
@ place interrupt in user mask
ldr r1, =UsrControllerMask
cmp r0, #32
addge r1, r1, #4	@ if device>=32, get IRQ 2
ldr r3, [r1]
orr r3, r3, r2
str r3, [r1]		@ add this device number to interrupt mask
@ add interrupt routine to driver table
ldr r0, =drivercount
ldr r1, [r0]
ldr r3, =drivertable
add r3, r3, r1, LSL #2
add r3, r3, r1, LSL #3	@ multiply by 12 to account 12 bytes per driver entry
add r1, r1, #1		@ increase number of active drivers
str r1, [r0]
ldm r5, {r0-r2}		@ load user regs r0-r2 (device number, driver @, R12 val)
stm r3, {r0-r2}		@ store values in driver table entry
ldr r1, =ExecType
ldr r0, [r1]
add r0, r0, #0x10000	@ Update ExecType: it should skip going to the GUI
str r0, [r1]
b Default_checkinstr
NotRunClaimDev:
ldr r1, =ExecType
ldr r0, [r1]
add r0, r0, #0x1500	@ Throw error: this device cannot be used
str r0, [r1]
b End_checkinstr

Else_checkinstr7:
ldr r1, =Code_OSReleaseDeviceVector
cmp r4, r1
bne End_checkinstr
ldr r0, [r5]		@ load user reg r0 (device number)
ldr r1, =drivercount
ldr r2, [r1]
ldr r3, =drivertable
add r3, r3, r2, LSL #2
add r3, r3, r2, LSL #3	@ multiply by 12 to account 12 bytes per driver entry
E_c7_fori:
cmp r2, #0
beq NotSetDev		@ if specified device is not in the table, throw error
ldr r4, [r3, #-12]!	@ it starts loop pointing past last element in driver table
sub r2, r2, #1
cmp r4, r0
bne E_c7_fori
ldr r0, [r5, #4]	@ load user reg r1 (routine address)
ldr r4, [r3, #4]	@ get routine address from entry in driver table
cmp r0, r4
ldrne r0, [r5]		@ restore in r0 the device number and jump back to the
bne E_c7_fori		@ loop if the addresses do not match
ldr r0, [r5, #8]	@ load user reg r2 (r12 value at entry of the routine)
ldr r4, [r3, #8]	@ get r12 value from entry in driver table
cmp r0, r4
ldrne r0, [r5]		@ if values do not match, reload device number and go back to
bne E_c7_fori		@ the loop
@ released device matches entry in table... remove entry (pushing forward any
@ entries behind), decrease number of drivers, and remove interrupt from user mask
ldr r4, [r1]
sub r4, r4, #1		@ decrease number of drivers for 2 reasons: to update value,
E_c7_forj:              @ and because last entry has to be cleared
cmp r2, r4
bge E_c7_endfor
stmdb sp!, {r0-r3}
add r3, r4, #12		@ move pointer to next entry
ldm r3, {r0-r2}		@ load values from entry
stm r4, {r0-r2}		@ store in entry-1
ldmia sp!, {r0-r3}
add r4, r4, #12		@ move pointer forward
add r2, r2, #1
b E_c7_forj		@ go to the beginning of the loop
E_c7_endfor:
str r4, [r1]		@ update number of drivers
ldr r0, [r5]		@ get device number
mov r2, #1
lsl r2, r2, r0		@ translate device number into its bit within mask
ldr r1, =UsrControllerMask
cmp r0, #32
addge r1, r1, #4	@ if device>=32, get IRQ 2
ldr r3, [r1]
bic r3, r3, r2
str r3, [r1]		@ remove this device number to interrupt mask

ldr r1, =ExecType
ldr r0, [r1]
add r0, r0, #0x10000	@ Update ExecType: it should skip going to the GUI
str r0, [r1]
b Default_checkinstr
NotSetDev:
ldr r1, =ExecType
ldr r0, [r1]
add r0, r0, #0x1600	@ Throw error for Device not Released
str r0, [r1]
b End_checkinstr

Default_checkinstr:
@ Do not execute the instruction
@ Move forward PC
ldr r1,[r5,#60] @ PC
add r1, r1, #4
str r1,[r5,#60] @ PC = PC + 4

End_checkinstr:
ldr r1,=ExecType
ldr r0, [r1]
ldmia sp!, {r4, r5, pc}

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@   Function (ReturnCLI) that determines whether to execute another instruction or go
@	back to the CLI.
@	It returns a 0 in r0 if the execution is NOT resumed
@
ReturnCLI:
ldr r1,=ExecType
ldr r0,[r1]
bic r0, #0x10000	@ clear bit to jump current instruction
str r0, [r1]
cmp r0,#1
beq modeGO
cmp r0,#2
beq modeTR
cmp r0,#3
beq modeGT
cmp r0,#4
beq modeGD
cmp r0, #0x10
beq modeGF
b   No_execute

modeGO:     @ In GO mode
@
@ Check if it is a Brkpt from the list; if so, set ExecType to 0 and jump to No_execute
@
ldr r0,=CurContext
ldr r5,[r0,#60]      @ Load the PC of next instruction
ldr r0,=CurNumBr
ldr r6,[r0]          @ Load the number of BreakPoints
ldr r0, =BrkPtList     @ Pointer to BreakPoints List
loop_GO:
   cmp r6,#0
   beq End_BrkList
   ldr r1,[r0]
   cmp r5,r1
   bne Next_Brk
   ldr r1,=ExecType
   ldr r0, [r1]
   add r0, r0, #0x1000   @ Write the Stop_Br constant to warn of a reached breakpoint
   str r0,[r1]
   mov r0, #0
   b End_RetCLI
Next_Brk:
   sub r6, r6, #1
   add r0, r0, #4
   b   loop_GO
End_BrkList:
@
@ increase the loop counter and check if the limit is reached; if so, jump to No_execute
@ without altering ExecType
@
ldr r0, =Loop
ldr r1,[r0]
add r1, r1, #1
str r1,[r0]
ldr r0, =Num_Loop
cmp r0,r1
beq No_execute

b Execute

modeTR:     @ In TR mode
@
@ Never execute the following instruction, it always returns to the CLI...
@ UNLESS there has been a data abort due to paging error
@
ldr r0, =PrefetchAddress
ldr r0, [r0]
cmp r0, #0	@ If address is non-zero, repeat the instruction
bne Execute
mov r0,#0
b End_RetCLI

modeGT:  @ In GT mode
@
@ stops if the address matches a temporary Brkpt or the max number of loops is reached
@
ldr r0,=CurContext
ldr r5,[r0,#60]      @ Load the PC of next instruction

ldr r0, =GTBrkP     @ Pointer to BreakPoint
ldr r1,[r0]

cmp r5,r1
bne No_BrkT
ldr r1,=ExecType
ldr r0, [r1]
add r0, r0, #0x1000   @ Write the Stop_Br constant to warn the breakpoint has been reached
str r0,[r1]
mov r0, #0
b End_RetCLI

No_BrkT:
@
@ increase the loop counter and check if the limit is reached; if so, jump to No_execute
@ without altering ExecType
@
ldr r0, =Loop
ldr r1,[r0]
add r1, r1, #1
str r1,[r0]
ldr r0, =Num_Loop
cmp r0,r1
beq No_execute
b Execute

modeGD:    @ In GD mode
@
@ it only stops if the max number of loops is reached;
@ increase the loop counter and check if the limit is reached; if so, jump to No_execute
@ without altering ExecType
@
ldr r0, =Loop
ldr r1,[r0]
add r1, r1, #1
str r1,[r0]
ldr r0, =Num_Loop
cmp r0,r1
bne Execute
b No_execute

modeGF:		@ In GoFast mode
@
@ it stops if a breakpoint set by the user has been reached
ldr r0,=CurContext
ldr r5,[r0,#60]			@ Load the PC of next instruction
ldr r0,=CurNumBr
ldr r6,[r0]			@ Load the number of BreakPoints
ldr r0, =BrkPtList		@ Pointer to BreakPoints List
loop_GF:
   cmp r6,#0
   beq Execute
   ldr r1,[r0]
   cmp r5,r1
   beq end_loop_GF
   sub r6, r6, #1
   add r0, r0, #4
   b   loop_GF
end_loop_GF:
   ldr r1,=ExecType
   ldr r0, [r1]
   add r0, r0, #0x1000   	@ Write the Stop_Br constant to warn of a
   str r0,[r1]			@ reached breakpoint

No_execute:
mov r0,#0
b End_RetCLI
Execute:
mov r0,#0xFF
End_RetCLI:
mov pc,lr

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@ set a breakpoint in the loaded program after its pc and on potential branches
@	Register use:
@	-r0-r3: aux vars
@	-r4: user PC
@	-r5: next instruction to execute
@	-r6: current context structure (bank of registers from the user)
@	-r7: masked instruction (to execute and determine next PC)
@
setimmediatebreakpoints:
stmdb sp!, {r4-r7, lr}
bl loadAuxCurContext	@ update aux table to get regs from current user mode
ldr r6, =AuxCurContext
ldr r4, [r6, #60]	@ get PC
ldr r5, [r4]		@ instruction to be executed

@ Check if instruction will be executed; otherwise, next inst is PC+4
and r0, r5, #Cond_Mask		@ get condition field from the instruction
cmp r0, #0xE0000000
beq sib_checkbranch		@ inconditional exec, check type of inst

				@ conditional execution
lsr r0, r0, #28			@ place condition field at the least significant bits
ldr r1, [r6, #64]		@ load CPSR from CurContext
bl CheckInstCond
cmp r0, #0
beq sib_nextinst		@ the instruction will not be exec'ed, next @ is PC+4

sib_checkbranch:		@ check if the instruction is a B/BL
and r0, r5, #0x0E000000		@ mask to get instruction type
cmp r0, #0x0A000000
bne sib_checkldm
bic r0, r5, #0xFF000000		@ get 24-bit immediate field
tst r0, #0x00800000		@ if the most significant bit is 1,
orrne r0, r0, #0xFF000000	@ the imm is negative => extend the sign
add r0, r4, r0, LSL #2		@ PC + immediate * 4
add r0, r0, #8			@ + 8
b sib_setbrk

sib_checkldm:			@ check if the instruction is a LDM
and r0, r5, #0x0E100000		@ mask to get instruction type
cmp r0, #0x08100000             @ check if the instruction is a LDM
bne sib_checkdprs
ands r0, r5, #0x8000		@ check if the PC is updated in the LDM
beq sib_nextinst		@ the PC will not be updated, next @ is PC+4
ldr r0, =0x7FFF			@ mask to get the number of regs loaded, including PC
and r0, r5, r0			@ list of regs loaded (1 bit per reg)
mov r1, #0			@ counter of number of registers
sib_loop_ldm:
ands r2, r0, #1			@ test least significant bit
addne r1, r1, #1		@ if bit=1, increase count
lsrs r0, r0, #1			@ discard that bit
bne sib_loop_ldm
and r0, r5, #0xF0000		@ get field 'register with the base address'
ldr r0, [r6, r0, LSR #14]	@ base address=mem(CurContext+reg with base @ * 4)
and r2, r5, #0x01800000		@ get addressing mode field from the instruction
lsr r2, r2, #23
cmp r2, #1
ldreq r0, [r0, r1, LSL #2]	@ IA => base address + off * 4
cmp r2, #2
ldreq r0, [r0, #-4]		@ DB => base address - 4
cmp r2, #3
addeq r1, #1
ldreq r0, [r0, r1, LSL #2]	@ IB => base address + (off * 4) + 4
cmp r2, #0
ldreq r0, [r0]			@ DA => base address
b sib_setbrk

sib_checkdprs:          	@ check if it is a data processing register shift
ldr r0, =0x0E000090     	@ mask to get instruction type
and r0, r5, r0
cmp r0, #0x00000010
bne sib_checkdpis
and r0, r5, #0x0F900000		@ mask to see if it is a misc instr
cmp r0, #0x01000000		@ check if misc instr
beq sib_nextinst
and r0, r5, #0xF000		@ check if the dest reg is PC
cmp r0, #0xF000
bne sib_nextinst		@ the PC will not be updated, next @ is PC+4
ldr r0, =0xF00FFF0F		@ mask to clear 'cond', 'Rd', 'Rn', 'Rm' and 'Rs' fields
bic r7, r5, r0
ldr r0, =0xE0010302		@ set cond=AL, Rd=r0, Rn=r1, Rm=r2, Rs=r3
orr r7, r7, r0
b sib_grfi_arg3

sib_checkdpis:          	@ check if it is a load with reg offset or
				@ a data processing immediate shift
ldr r0, =0x0E100010		@ mask to get instruction type
and r0, r5, r0
cmp r0, #0x06100000		@ check if load with reg offset
ldrne r0, =0x0E000010		@ mask to get instruction type
andnes r0, r5, r0		@ check if data processing immediate shift
bne sib_checkdpi
ldr r0, =0x0F900010		@ mask to see if a misc instr
and r0, r5, r0
cmp r0, #0x01000000		@ check if it is a misc instr
beq sib_nextinst
and r0, r5, #0xF000		@ check if the dest reg is PC
cmp r0, #0xF000
bne sib_nextinst		@ the PC will not be updated, next @ is PC+4
ldr r0, =0xF00FF00F		@ mask to clear 'cond', 'Rd', 'Rn', and 'Rm' fields
bic r7, r5, r0
ldr r0, =0xE0010002		@ set cond=AL, Rd=r0, Rn=r1, Rm=r2
orr r7, r7, r0
b sib_grfi_arg2

sib_checkdpi:           	@ check if instruction is a data pocessing immediate
				@ or a load with immediate offset
and r0, r5, #0x0E000000		@ mask to get instruction type
cmp r0, #0x02000000             @ check if data processing immediate
andne r0, r5, #0x0E100000
cmpne r0, #0x04100000		@ check if load immediate offset
bne sib_nextinst		@ none of the instructions that affect PC, next @ is PC+4
and r0, r5, #0xF000		@ check if the dest reg is PC
cmp r0, #0xF000
bne sib_nextinst		@ the PC will not be updated, next @ is PC+4
ldr r0, =0xF00FF000		@ mask to clear 'cond', 'Rd', and 'Rn' fields
bic r7, r5, r0
ldr r0, =0xE0010000		@ set cond=AL, Rd=r0, Rn=r1
orr r7, r7, r0
b sib_grfi_arg1

sib_grfi_arg3:			@ load in r3 the value of the Rs from the inst
and r3, r5, #0xF00		@ get Rs
ldr r3, [r6, r3, LSR #6]	@ r3 = mem(CurContext + Rs * 4)
sib_grfi_arg2:			@ load in r2 the value of the Rm from the inst
and r2, r5, #0xF		@ get Rm
ldr r2, [r6, r2, LSL #2]	@ r2 = mem(CurContext + Rm * 4)
sib_grfi_arg1:
and r1, r5, #0xF0000		@ get Rn
ldr r1, [r6, r1, LSR #14]	@ r1 = mem(CurContext + Rn * 4)
ldr r0, =GetResultFromInst
str r7, [r0]			@ store instruction to exec it
mov r0,#0 			@ flags, 0 for all memory
swi 0x6E @ OS_SynchronizeCodeAreas
bl GetResultFromInst
b sib_setbrk			@ set the breakpoint at the future PC

sib_nextinst:			@ Consecutive execution: next inst is at PC+4
add r0, r4, #4

sib_setbrk:			@ Set the breakpoint
stmdb sp!, {r0-r3}              @ store context to keep it after function call
bl validMemAddressRange
cmp r0, #0
ldmia sp!, {r0-r3}
beq sib_end                     @ if address is outside user range, do not place
				@ breakpoint (to account for IRQ release function)
ldr r1, [r0] 			@ instruction to be saved
ldr r2, =immediatebreakpoints
str r0, [r2], #4		@ save address
str r1, [r2], #4		@ save content
ldr r1, =BrkpInst
str r1, [r0]			@ set the bkpt
mov r0, #1			@ breakpoint counter
ldr r1, =immediatebreakpointnumber
str r0, [r1]			@ store the breakpoint counter

mov r0,#0 @ flags, 0 for all memory
swi 0x6E @ OS_SynchronizeCodeAreas
sib_end:
ldmia sp!, {r4-r7, pc}


GetResultFromInst:
bkpt @brkpt to provoke a prefetch abort (this inst should be replaced)
mov pc, lr

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@ Set breakpoints for go-fast mode (at every breakpoint established by the user
@ and at every SWI whose execution is captured)
@
setfastbreakpoints:
ldr lr, =jtp
stmdb sp!, {r4-r6, lr}
ldr r4, =BrkpInst
ldr r5, =immediatebreakpoints
ldr r6, =immediatebreakpointnumber
mov r0, #0
str r0, [r6]	@ Reset # of breakpoints

@ check the whole code (from the beginning of ELF file to beginning of data
@ section)
ldr r0, =AddrElfFile
ldr r0, [r0]
ldr r1, =AddrCodeEnd
ldr r1, [r1]
sfb_loop:
ldr r2, [r0]		@ get instruction
and r3, r2, #SWI_Mask
cmp r3, #SWI_Mask
bne sfb_checkinstr_end
bic r2, r2, #Cond_Mask
ldr r3, =Code_OSExit
cmp r2, r3
beq sfb_setbrk
ldr r3, =Code_OSWriteStr
cmp r2, r3
beq sfb_setbrk
ldr r3, =Code_OSWriteChar
cmp r2, r3
beq sfb_setbrk
ldr r3, =Code_OSGetChar
cmp r2, r3
beq sfb_setbrk
ldr r3, =Code_OSEnterOS
cmp r2, r3
beq sfb_setbrk
ldr r3, =Code_OSLeaveOS
cmp r2, r3
beq sfb_setbrk
ldr r3, =Code_OSClaimDeviceVector
cmp r2, r3
beq sfb_setbrk
ldr r3, =Code_OSReleaseDeviceVector
bne sfb_checkinstr_end

sfb_setbrk:			@ set a breakpoint
ldr r2, =CurContext
ldr r2, [r2, #60]               @ get PC
cmp r2, r0
beq sfb_checkinstr_end          @ do not place brkpt in current PC
ldr r2, [r0]			@ instruction to be saved
str r0, [r5], #4		@ save address
str r2, [r5], #4		@ save content
str r4, [r0]			@ set the bkpt
ldr r3, [r6]
add r3, r3, #1			@ increase breakpoint counter
str r3, [r6]			@ store the breakpoint counter

sfb_checkinstr_end:
add r0, r0, #4
cmp r0, r1
blt sfb_loop

@ Now checked the breakpoints established by the user;
@ check if any matches one already set
ldr r0,=CurNumBr
ldr r0,[r0]			@ Load the number of BreakPoints
cmp r0, #0
beq sfb_return			@ if no breakpoints, return from routine
ldr r1, =BrkPtList		@ pointer to BreakPoints List
sfb_loop2:
ldr r2, [r1], #4		@ get address of the breakpoint
ldr r3, =CurContext
ldr r3, [r3, #60]               @ get PC
cmp r2, r3
beq sfb_checkloop2		@ do not place brkpt in current PC
ldr r3, [r2]
cmp r3, r4			@ check if a breakpoint is already in place
beq sfb_checkloop2
str r2, [r5], #4		@ save address
str r3, [r5], #4		@ save content
str r4, [r2]			@ set the bkpt
ldr r3, [r6]
add r3, r3, #1			@ increase breakpoint counter
str r3, [r6]			@ store the breakpoint counter

sfb_checkloop2:
subs r0, r0, #1
bne sfb_loop2

sfb_return:
mov r0,#0 @ flags, 0 for all memory
swi 0x6E @ OS_SynchronizeCodeAreas

ldmia sp!, {r4-r6, pc}


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@ Remove the breakpoints
@
clearimmediatebreakpoints:
ldr r3,=immediatebreakpoints
ldr r0,[r3,#-4] @ number of breakpoints
clearimmediatebreakpoints_loop:
ldr r1,[r3],#4 @ address
ldr r2,[r3],#4 @ content
str r2,[r1]
subs r0,r0,#1
bgt clearimmediatebreakpoints_loop
mov r0,#0 @ all memory
swi 0x6E @ OS_SynchronizeCodeAreas
mov pc,lr

.end

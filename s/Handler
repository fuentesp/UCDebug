@ !UCDebug, ARM debugger for RISC OS.
@ https://github.com/fuentesp/UCDebug
@ Copyright (C) 2018  University of Cantabria
@
@ !UCDebug was developed by the Computer Architecture and Technology
@ Group at the University of Cantabria. A comprehensive list of authors
@ can be found in the file AUTHORS.txt.
@
@ You can reach the main developers at {fernando.vallejo, cristobal.camarero,
@ pablo.fuentes}@unican.es.
@
@ This program is free software: you can redistribute it and/or modify
@ it under the terms of the GNU General Public License as published by
@ the Free Software Foundation, either version 3 of the License, or
@ (at your option) any later version.
@
@ This program is distributed in the hope that it will be useful,
@ but WITHOUT ANY WARRANTY; without even the implied warranty of
@ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@ GNU General Public License for more details.
@
@ You should have received a copy of the GNU General Public License
@ along with this program.  If not, see <https://www.gnu.org/licenses/>.

.global   PrefetchAbortHandler
.global   UndefinedInstructHandler
.global   DataAbortHandler
.global   IRQHandler
.global   ReleaseHandler
.extern   CurContext
.extern   ExecType

.equ BrkpInst,    0xE1200071

.data

.align 2
IRQregBkup:	.space 24	@ Space to store temp regs (r0-r3, r12) and prev PC

.text

PrefetchAbortHandler:
@@ Save context from all modes, starting from Abort mode
str r0, [sp, #-4]!
ldr r0,=CurContext
stm r0,{r0-r12}
ldr r1, [sp], #4
str r1, [r0]		@ write program r0 in its place in CurContext
sub r1,lr,#4
str r1,[r0,#60] @ write program pc in its place (it is lr while in exception)
add r2, r0, #68
vstm r2!, {s0-s31} @ write floating-point regs
vmrs r3, FPSCR
str r3, [r2] @ write FPSCR
str sp, [r0, #212] @ write abort sp
@str lr, [r0, #216] @ write abort lr
mrs r3, spsr
str r3, [r0, #220] @ write abort SPSR
str r3, [r0, #64] @ write program CPSR (copied to SPSR when accessing excep)
orr r3, r3, #0x180	@ Disable interrupts and imprecise aborts
orr r3, r3, #0x1F
msr cpsr, r3 @ switch to system mode to access remaining user regs
str sp, [r0, #52] @ write program sp in its place
str lr, [r0, #56] @ write program lr in its place
bic r3, r3, #0x4
msr cpsr, r3 @ switch from System to Undefined mode
str sp, [r0, #224] @ write undefined sp
str lr, [r0, #228] @ write undefined lr
mrs r2, spsr
str r2, [r0, #232] @ write undefined SPSR in its place
bic r3, r3, #0x9
msr cpsr, r3 @ switch from Und to IRQ mode
mrs r2, spsr
str r2, [r0, #244] @ write IRQ SPSR in its place
str sp, [r0, #236] @ write IRQ sp
str lr, [r0, #240] @ write IRQ lr
orr r3, r3, #0x1
msr cpsr, r3 @ switch from IRQ to Supervisor mode
mrs r2, spsr
str r2, [r0, #208] @ write supervisor SPSR in its place
str sp, [r0, #200] @ write supervisor sp
str lr, [r0, #204] @ write supervisor lr
bic r3, r3, #0x2
msr cpsr, r3 @ switch to FIQ mode
mrs r2, spsr
str r2, [r0, #276] @ write FIQ SPSR in its place
add r2, r0, #248
stm r2, {r8-r14} @ write FIQ specific regs
orr r3, r3, #0x1F
msr cpsr, r3 @ switch to sys mode

ldr r0,[r1]    @ read the instruction
ldr r2,=BrkpInst @ code for bkpt 1
cmp r0,r2
beq ReleaseHandler
@ mark Prefetch Abort
ldr r1,=ExecType
mov r0, #0x1300
str r0,[r1]

ldr r0,=CurContext
ldr r1, [r0, #60]
add r1, r1, #4
str r1, [r0, #216] @ write abort lr (only if it is not a breakpoint)
b  ReleaseHandler

UndefinedInstructHandler:
@@ Save context from all modes, starting from Undefined mode
str r0, [sp, #-4]!
ldr r0,=CurContext
stm r0,{r0-r12}
ldr r1, [sp], #4
str r1, [r0]		@ write program r0 in its place in CurContext
sub r1,lr,#4
str r1,[r0,#60] @ write program pc in its place (it is lr while in exception)
add r2, r0, #68
vstm r2!, {s0-s31} @ write floating-point regs
vmrs r3, FPSCR
str r3, [r2] @ write FPSCR
str sp, [r0, #224] @ write undefined sp
str lr, [r0, #228] @ write undefined lr
mrs r3, spsr
str r3, [r0, #232] @ write undefined SPSR in its place
str r3, [r0, #64] @ write program CPSR (copied to SPSR when accessing excep)
orr r3, r3, #0x180	@ Disable interrupts and imprecise aborts
orr r3, r3, #0x1F
msr cpsr, r3 @ switch to system mode to access remaining user regs
str sp, [r0, #52] @ write program sp in its place
str lr, [r0, #56] @ write program lr in its place
bic r3, r3, #0xD
msr cpsr, r3 @ switch from System to IRQ mode
mrs r2, spsr
str r2, [r0, #244] @ write IRQ SPSR in its place
str sp, [r0, #236] @ write IRQ sp
str lr, [r0, #240] @ write IRQ lr
orr r3, r3, #0x1
msr cpsr, r3 @ switch from IRQ to Supervisor mode
mrs r2, spsr
str r2, [r0, #208] @ write supervisor SPSR in its place
str sp, [r0, #200] @ write supervisor sp
str lr, [r0, #204] @ write supervisor lr
bic r3, r3, #0x2
msr cpsr, r3 @ switch to FIQ mode
mrs r2, spsr
str r2, [r0, #276] @ write FIQ SPSR in its place
add r2, r0, #248
stm r2, {r8-r14} @ write FIQ specific regs
orr r3, r3, #0x6
msr cpsr, r3 @ switch from FIQ to abort mode
str sp, [r0, #212] @ write abort sp
str lr, [r0, #216] @ write abort lr
mrs r2, spsr
str r2, [r0, #220] @ write abort SPSR
orr r3, r3, #0x1F
msr cpsr, r3 @ switch to sys mode

@ mark Undefined Instruction
ldr r1,=ExecType
mov r0, #0x1200
str r0,[r1]

b  ReleaseHandler

DataAbortHandler:
@@ Save context from all modes, starting from Abort mode
str r0, [sp, #-4]!
ldr r0,=CurContext
stm r0,{r0-r12}
ldr r1, [sp], #4
str r1, [r0]		@ write program r0 in its place in CurContext
sub r1, lr, #8
str r1, [r0, #60] 	@ write program pc in its place (it is lr while in exception)
add r2, r0, #68
vstm r2!, {s0-s31} @ write floating-point regs
vmrs r3, FPSCR
str r3, [r2] @ write FPSCR
str sp, [r0, #212] @ write abort sp
str lr, [r0, #216] @ write abort lr
mrs r3, spsr
str r3, [r0, #220] @ write abort SPSR
str r3, [r0, #64] @ write program CPSR (copied to SPSR when accessing excep)
orr r3, r3, #0x180	@ Disable interrupts and imprecise aborts
orr r3, r3, #0x1F
msr cpsr, r3 @ switch to system mode to access remaining user regs
str sp, [r0, #52] @ write program sp in its place
str lr, [r0, #56] @ write program lr in its place
bic r3, r3, #0x4
msr cpsr, r3 @ switch from System to Undefined mode
str sp, [r0, #224] @ write undefined sp
str lr, [r0, #228] @ write undefined lr
mrs r2, spsr
str r2, [r0, #232] @ write undefined SPSR in its place
bic r3, r3, #0x9
msr cpsr, r3 @ switch from Und to IRQ mode
mrs r2, spsr
str r2, [r0, #244] @ write IRQ SPSR in its place
str sp, [r0, #236] @ write IRQ sp
str lr, [r0, #240] @ write IRQ lr
orr r3, r3, #0x1
msr cpsr, r3 @ switch from IRQ to Supervisor mode
mrs r2, spsr
str r2, [r0, #208] @ write supervisor SPSR in its place
str sp, [r0, #200] @ write supervisor sp
str lr, [r0, #204] @ write supervisor lr
bic r3, r3, #0x2
msr cpsr, r3 @ switch to FIQ mode
mrs r2, spsr
str r2, [r0, #276] @ write FIQ SPSR in its place
add r2, r0, #248
stm r2, {r8-r14} @ write FIQ specific regs
orr r3, r3, #0xF
msr cpsr, r3 @ switch to sys mode

@ check if data abort is due to paging error
mrc p15, 0, r0, cr5, cr0, 0	@ Fault status register
mov r1, #0x400
orr r1, r1, #0xF                @ Mask for fault status
and r0, r0, r1
cmp r0, #0x7
bne mDAb			@ If fault!=0b0111, mark as data abort
mrc p15, 0, r0, cr6, cr0, 0	@ Conflict address
mov r1, r0
swi 0x3A @ OS_ValidateAddress
bcs mDAb			@ If C flag active, address is outside valid range
ldr r0, =PrefetchAddress	@ If valid address, store it to prefetch in
str r1, [r0]			@ the next loop,
b ReleaseHandler		@ and do not mark data abort

@ mark Data Abort
mDAb:
ldr r1,=ExecType
mov r0, #0x1100
str r0,[r1]

b ReleaseHandler

IRQHandler:
@@ Save context from all modes, starting from IRQ mode
stmdb sp!, {r0-r4, r12}
sub r0, lr, #4		@ get program pc to call function (it is lr while in exception)
mov r4, r0		@ also keep it in a safe register
bl validMemAddressRange
cmp r0, #0
addeq sp,sp,#24
beq IRQH_CheckIRQ	@ if PC non-valid, do not store current context
ldr r0,=CurContext
stm r0,{r0-r12}
str r4, [r0, #60] 	@ write program pc in its place
ldmia sp!, {r1-r5, r6}
stm r0, {r1-r5}		@ write program r0-r4 in their place in CurContext
str r6, [r0, #48]	@ write program r12 (ip) in its place
add r2, r0, #68
vstm r2!, {s0-s31} @ write floating-point regs
vmrs r3, FPSCR
str r3, [r2] @ write FPSCR
mrs r3, spsr
str r3, [r0, #244] @ write IRQ SPSR in its place
str sp, [r0, #236] @ write IRQ sp
str lr, [r0, #240] @ write IRQ lr
orr r3, r3, #0x180	@ Disable interrupts and imprecise aborts
orr r3, r3, #0x1F
msr cpsr, r3 @ switch to system mode to access remaining user regs
str sp, [r0, #52] @ write program sp in its place
str lr, [r0, #56] @ write program lr in its place
bic r3, r3, #0x4
msr cpsr, r3 @ switch from System to Undefined mode
str sp, [r0, #224] @ write undefined sp
str lr, [r0, #228] @ write undefined lr
mrs r2, spsr
str r2, [r0, #232] @ write undefined SPSR in its place
bic r3, r3, #0x8
msr cpsr, r3 @ switch from undefined to Supervisor mode
mrs r2, spsr
str r2, [r0, #208] @ write supervisor SPSR in its place
str sp, [r0, #200] @ write supervisor sp
str lr, [r0, #204] @ write supervisor lr
orr r3, r3, #0x4
msr cpsr, r3 @ switch from supervisor to Abort mode
mrs r2, spsr
str sp, [r0, #212] @ write abort sp
str lr, [r0, #216] @ write abort lr
str r2, [r0, #220] @ write abort SPSR
bic r3, r3, #0x6
msr cpsr, r3 @ switch from Abort to FIQ mode
mrs r2, spsr
str r2, [r0, #276] @ write FIQ SPSR in its place
add r2, r0, #248
stm r2, {r8-r14} @ write FIQ specific regs
IRQH_CheckIRQ:
mrs r3, cpsr
orr r3, r3, #0x180	@ Disable interrupts and imprecise aborts
orr r3, r3, #0xF
msr cpsr, r3 		@ switch to sys mode
@ Check if entry has an associated driver in the table
ldr r0, =drivercount
ldr r0, [r0]
ldr r1, =drivertable
add r1, r0, LSL #2	@ get past last element in driver table (base + offset of
add r1, r0, LSL #3	@ num drivers * 12 bytes per entry)

IRQH_while:
cmp r0, #0
beq ReleaseHandler	@ none of the devices in the table provoked the interrupt,
			@ let RISC OS handle it
sub r0, r0, #1
ldr r2, [r1, #-12]!	@ get number of device from driver table
rsb r4, r2, #64         @ get (64-dev) to perform translation to bit position
		@ (consider that for IRQ 1 & 2, bit position has to be below 32)
cmp r2, #32		@ check if it is IRQ 1 (<32) or 2 (>32)
mov r3, #1
ror r4, r3, r4           @ translate number of device into bit position
ldr r3, =ControllerBaseAddress
ldr r3,[r3]
ldrlt r3, [r3, #0x204]	@ if dev < 32, get pending IRQs 1
ldrge r3, [r3, #0x208]	@ if dev >= 32, get pending IRQs 2
tst r4, r3
beq IRQH_while

IRQH_attend:
@ Attend the interrupt: make Dbgr jump to user driver
ldr r0, =CurContext
ldr r6, =IRQregBkup
ldm r0, {r2-r5}
stmia r6!, {r2-r5}		@ bkup of user temp regs (r0-r3)
ldr r2, [r0, #48]
str r2, [r6], #4 		@ plus r12
ldr r2, [r0, #60]
str r2, [r6]     		@ and current user PC
ldr r2, [r1, #4]		@ get driver address
str r2, [r0, #60]		@ and store it in user PC
ldr r2, [r1, #8]		@ get R12 value for driver
str r2, [r0, #48]		@ and store it in user R12 reg
ldr r1, [r0, #64]		@ get user CPSR
str r1, [r0, #244]		@ store previous CPSR in IRQ SPSR
bic r1, r1, #0x1F		@ clear current user mode
orr r1, r1, #0x12		@ update user CPSR to IRQ mode
orr r1, r1, #0x180		@ disable IRQs
str r1, [r0, #64]
ldr r1, =IRQFinishHandler	@ store return @ (function to get back to prev mode)
str r1, [r0, #240]		@ in IRQ lr
b ReleaseHandler

@
@ User routine has finished attending an interrupt, get user back to its previous
@ context.
@
IRQFinishHandler:
mrs r2, cpsr
ands r1, r2, #0xF
swieq 0x16			@ if in user mode, switch to SVC
orr r2, r2, #0x180		@ disable IRQs
orr r2, r2, #0x1F
msr cpsr, r2			@ switch to SYS mode
@@ Save context from all modes, starting from SYS mode
ldr r0, =CurContext
add r1, r0, #16                 @ write program r4-r14 in CurContext (remember
stm r1, {r4-r14}		@ that r0-r3 & r12 are restored later from bkup)
add r1, r0, #68
vstm r1!, {s0-s31} 		@ write floating-point regs
vmrs r3, FPSCR
str r3, [r1] 			@ write FPSCR
bic r2, r2, #0xD		@ switch from SYS to IRQ
msr cpsr, r2
mrs r3, spsr
str r3, [r0, #244] 		@ write IRQ SPSR in its place
str sp, [r0, #236] 		@ write IRQ sp
str lr, [r0, #240] 		@ write IRQ lr
orr r2, r2, #0x9		@ switch from IRQ to Undefined mode
msr cpsr, r2
str sp, [r0, #224] 		@ write undefined sp
str lr, [r0, #228] 		@ write undefined lr
mrs r3, spsr
str r3, [r0, #232] 		@ write undefined SPSR in its place
bic r2, r2, #0x8
msr cpsr, r2 			@ switch from undefined to Supervisor mode
mrs r3, spsr
str r3, [r0, #208] 		@ write supervisor SPSR in its place
str sp, [r0, #200] 		@ write supervisor sp
str lr, [r0, #204] 		@ write supervisor lr
orr r2, r2, #0x4
msr cpsr, r2 			@ switch from supervisor to Abort mode
mrs r3, spsr
str sp, [r0, #212] 		@ write abort sp
str lr, [r0, #216] 		@ write abort lr
str r3, [r0, #220] 		@ write abort SPSR
bic r2, r2, #0x6
msr cpsr, r2			@ switch from Abort to FIQ mode
mrs r3, spsr
str r3, [r0, #276] 		@ write FIQ SPSR in its place
add r3, r0, #248
stm r3, {r8-r14} 		@ write FIQ specific regs
orr r2, r2, #0x1F		@ switch back to SYS mode
msr cpsr, r2

ldr r1, =IRQregBkup
ldmia r1!, {r2-r5}
stm r0, {r2-r5}			@ restore bkup of user temp regs (r0-r3)
ldr r2, [r1], #4 		@ plus r12
str r2, [r0, #48]
ldr r2, [r1]     		@ and current user PC
str r2, [r0, #60]
ldr r1, [r0, #244]		@ get SPSR from user IRQ mode
str r1, [r0, #64]		@ and restore it in user CPSR
b ReleaseHandler


ReleaseHandler:
ldr r0,=ourregisters
mrs r1, CPSR
orr r1,r1,#0xF
bic r1, r1, #0xC
orr r1, r1, #0x180 @ disable IRQ
msr CPSR, r1       @ switch from Sys to SVC
ldr sp, [r0, #200] @ load debugger SVC sp
ldr lr, [r0, #204] @ load debugger SVC lr
ldr r2, [r0, #208]
msr spsr, r2       @ load debugger SVC spsr
bic r1, r1, #0x1
msr cpsr, r1 @ switch from SVC to IRQ mode
ldr sp, [r0, #236] @ load IRQ sp
ldr lr, [r0, #240] @ load IRQ lr
ldr r2, [r0, #244]
msr spsr, r2       @ load IRQ SPSR
orr r1, r1, #0x5
msr cpsr, r1 @ switch from IRQ to Abt mode
ldr sp, [r0, #212] @ load abort sp
ldr lr, [r0, #216] @ load abort lr
ldr r2, [r0, #220]
msr spsr, r2       @ load abort SPSR
bic r1, r1, #0x6
msr cpsr, r1 @ switch from Abt to FIQ mode
add r2, r0, #248
ldm r2, {r8-r14}   @ load FIQ specific regs
ldr r2, [r0, #276]
msr spsr, r2       @ load FIQ SPSR
orr r1, r1, #0xA
msr cpsr, r1 @ switch from FIQ to Und mode
ldr sp, [r0, #224] @ load undefined sp
ldr lr, [r0, #228] @ load undefined lr
ldr r2, [r0, #232]
msr spsr, r2       @ load undefined SPSR
orr r1, r1, #0x1F
msr cpsr, r1 @ switch to Sys mode
ldm r0, {r0-r14}  @ recover general purpose regs (previous usr mode is unknown)

@
@ write disable and enable IRQ regs to restore interrupts from GUI
@
mvn r1, #0			@ Load all bits to 1
mov r2, r1
bic r2, r2, #0x10000		@ Do NOT disable mouse
mov r3, r1
ldr r4, =ControllerBaseAddress
ldr r4, [r4]
add r5, r4, #0x21C
str r1, [r5], #4                @ Disable all interrupts
str r2, [r5], #4		@ one by one (a stm produces weird
str r3, [r5], #4		@ effects)
ldr r0, =DbgControllerMask
ldm r0, {r1-r3}
add r5, r4, #0x210
str r1, [r5], #4                @ Enable those interrupts used by the GUI
str r2, [r5], #4		@ one by one (a stm produces weird
str r3, [r5], #4		@ effects)

ldr r0,=HandDatRel
ldr r1,[r0]
mov r0,#0x4 @ release + data abort
ldr r2,=DataAbortHandler
swi 0x69 @ OS_ClaimProcessorVector

ldr r0,=HandUndRel
ldr r1,[r0]
mov r0,#0x1 @ release + UNdefined instruction
ldr r2,=UndefinedInstructHandler
swi 0x69 @ OS_ClaimProcessorVector

ldr r0,=HandPreRel
ldr r1,[r0]
mov r0,#0x3 @ release + prefetch abort
ldr r2,=PrefetchAbortHandler
swi 0x69 @ OS_ClaimProcessorVector

ldr r0,=HandIRQRel
ldr r1,[r0]
mov r0,#0x6 @ release + IRQ
ldr r2,=IRQHandler
swi 0x69 @ OS_ClaimProcessorVector

ldr r0,=ReturnHandler
ldr lr,[r0]
ldr r0,=StackHandler
ldr sp,[r0]

mrs r0,cpsr
bic r0,r0,#0x1C0	@ Re-enable imprecise aborts, fast interrupts,
msr cpsr,r0		@ and normal interrupts

mov pc, lr	@ Return in sys mode

.end

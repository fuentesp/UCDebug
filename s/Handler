@ !UCDebug, ARM debugger for RISC OS.
@ https://github.com/fuentesp/UCDebug
@ Copyright (C) 2018  University of Cantabria
@
@ !UCDebug was developed by the Computer Architecture and Technology
@ Group at the University of Cantabria. A comprehensive list of authors
@ can be found in the file AUTHORS.txt.
@
@ You can reach the main developers at {fernando.vallejo, cristobal.camarero,
@ pablo.fuentes}@unican.es.
@
@ This program is free software: you can redistribute it and/or modify
@ it under the terms of the GNU General Public License as published by
@ the Free Software Foundation, either version 3 of the License, or
@ (at your option) any later version.
@
@ This program is distributed in the hope that it will be useful,
@ but WITHOUT ANY WARRANTY; without even the implied warranty of
@ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
@ GNU General Public License for more details.
@
@ You should have received a copy of the GNU General Public License
@ along with this program.  If not, see <https://www.gnu.org/licenses/>.

.include  "s/Constants"

.global   PrefetchAbortHandler
.global   UndefinedInstructHandler
.global   DataAbortHandler
.global   IRQHandler
.global   ReleaseHandler
.global   IRQregBkup @just for prefteching
.extern   CurContext
.extern   ExecType
.extern   ControllerBaseAddress

.data

.align 2
IRQregBkup:	.space 24	@ Space to store temp regs (r0-r3, r12) and prev PC

.text

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@
@ Save context from all modes, starting from Abort mode
@
@  Use of regs during exec:
@	r0: address of CurContext
@	r1: PC/address of instruction
@	r2: aux pointer to CurContext
@	r3: CPSR and SPSR of every mode
@
PrefetchAbortHandler:
str r0, [sp, #-4]!
ldr r0,=CurContext
stm r0,{r0-r12}
ldr r1, [sp], #4
str r1, [r0]		@ write program r0 in its place in CurContext
sub r1,lr,#4
str r1,[r0,#60] @ write program pc in its place (it is lr while in exception)
add r2, r0, #OffFPRegs

vmrs r5, FPEXC					@ Save the FP exception status to r5 to later test
bic r3, r5, #0x80000000			@ against exception at Floating-Point unit
bic r3, r3, #0xff0				@ Clear any possible exception at the Floating-Point unit
vmsr fpexc, r3					@ in order to save the state of the FP registers
vstm r2!, {s0-s31} @ write floating-point regs
vmrs r3, FPSCR
str r3, [r2]			@ write FPSCR

@DUMP
@ldr r4,=ControllerBaseAddress
@ldr r4,[r4]
@ldr r4,[r4,#0x20C] @FIQ control
@str r4,[r0,#10*4] @ show FIQ as r10
@str r4,[r0,#9*4] @ show FIQ as r9

mrs r3, spsr
str r3, [r0, #OffCpsr]		@ write program CPSR (copied to SPSR when accessing excep)
str sp, [r0, #OffAbtRegs]	@ write abort sp
@str lr, [r0, #OffAbtRegs+4]	@ write abort lr [DO NOT! IT IS CHANGED WHEN ENTERING THE EXCEP]
str r3, [r0, #OffAbtRegs+8]	@ write abort SPSR
mov r4,#MaskDisIRQs
orr r3,r4,#MaskSvcMode
msr cpsr, r3			@ switch to Supervisor mode
mrs r3, spsr
add r2, r0, #OffSvcRegs
stmia r2!, {sp, lr}		@ write supervisor sp and lr
str r3, [r2], #4		@ write supervisor SPSR in its place
orr r3,r4,#MaskUndMode
msr cpsr, r3			@ switch to Undefined mode
mrs r3, spsr
add r2, r0, #OffUndRegs
stmia r2!, {sp, lr}		@ write undefined sp and lr
str r3, [r2], #4		@ write undefined SPSR in its place
orr r3,r4,#MaskIrqMode
msr cpsr, r3			@ switch to IRQ mode
mrs r3, spsr
stmia r2!, {sp, lr}		@ write IRQ sp and lr
str r3, [r2], #4		@ write IRQ SPSR in its place
orr r3,r4,#MaskFiqMode
msr cpsr, r3			@ switch to FIQ mode
mrs r3, spsr
add r2, r0, #OffFiqRegs
stmia r2!, {r8-r14}		@ write FIQ specific regs
str r3, [r2]			@ write FIQ SPSR in its place
orr r3,r4,#MaskSysMode
msr cpsr, r3			@ switch to system mode to access remaining user regs
str sp, [r0, #52]		@ write program sp in its place
str lr, [r0, #56]		@ write program lr in its place

ldr r0,[r1]    @ read the instruction
ldr r2,=BrkpInst @ code for bkpt 1
cmp r0,r2
beq PAH_CheckVFPEx
mPA:			@ mark Prefetch Abort
ldr r1,=ExecType
mov r0, #Ex_PAb
str r0,[r1]

ldr r0,=CurContext
ldr r1, [r0, #60]
add r1, r1, #4
str r1, [r0, #OffAbtRegs+4]	@ write abort lr (only if it is not a breakpoint)
b  ReleaseHandler

PAH_CheckVFPEx:		@ check VFP exception
tst r5, #0x80000000
beq ReleaseHandler
mVFPE:
ldr r1, =ExecType
mov r0, #Ex_VFP
str r0, [r1]		@ mark VFP exception
ldr r0,=CurContext
ldr r1, [r0, #60]
sub r1, r1, #4
str r1, [r0, #60]	@ write program PC in its place (the VFP exception does not stop execution)
b ReleaseHandler

UndefinedInstructHandler:
@@ Save context from all modes, starting from Undefined mode
str r0, [sp, #-4]!
ldr r0,=CurContext
stm r0,{r0-r12}
ldr r1, [sp], #4
str r1, [r0]		@ write program r0 in its place in CurContext
sub r1,lr,#4
str r1,[r0,#60] @ write program pc in its place (it is lr while in exception)
vmrs r3, FPEXC
bic r3, r3, #0x80000000
bic r3, r3, #0xff0				@ Clear any possible exception at the Floating-Point unit
vmsr fpexc, r3					@ in order to save the values of the FP registers.
add r2, r0, #OffFPRegs
vstm r2!, {s0-s31} @ write floating-point regs
vmrs r3, FPSCR
str r3, [r2] @ write FPSCR
str sp, [r0, #OffUndRegs] @ write undefined sp
str lr, [r0, #OffUndRegs+4] @ write undefined lr
mrs r3, spsr
str r3, [r0, #OffUndRegs+8] @ write undefined SPSR in its place
str r3, [r0, #OffCpsr] @ write program CPSR (copied to SPSR when accessing excep)
ldr r3, =MaskDisIRQs+MaskSysMode	@ Disable interrupts and imprecise aborts
msr cpsr, r3 @ switch to system mode to access remaining user regs
str sp, [r0, #52] @ write program sp in its place
str lr, [r0, #56] @ write program lr in its place
ldr r3, =MaskDisIRQs+MaskIrqMode
msr cpsr, r3 @ switch from System to IRQ mode
mrs r2, spsr
str r2, [r0, #OffIrqRegs+8] @ write IRQ SPSR in its place
str sp, [r0, #OffIrqRegs] @ write IRQ sp
str lr, [r0, #OffIrqRegs+4] @ write IRQ lr
orr r3, r3, #0x1
msr cpsr, r3 @ switch from IRQ to Supervisor mode
mrs r2, spsr
str r2, [r0, #OffSvcRegs+8] @ write supervisor SPSR in its place
str sp, [r0, #OffSvcRegs] @ write supervisor sp
str lr, [r0, #OffSvcRegs+4] @ write supervisor lr
ldr r3, =MaskDisIRQs+MaskFiqMode
msr cpsr, r3 @ switch to FIQ mode
mrs r2, spsr
str r2, [r0, #OffFiqRegs+28] @ write FIQ SPSR in its place
add r2, r0, #OffFiqRegs
stm r2, {r8-r14} @ write FIQ specific regs
ldr r3, =MaskDisIRQs+MaskAbtMode
msr cpsr, r3 @ switch from FIQ to abort mode
str sp, [r0, #OffAbtRegs] @ write abort sp
str lr, [r0, #OffAbtRegs+4] @ write abort lr
mrs r2, spsr
str r2, [r0, #OffAbtRegs+8] @ write abort SPSR
ldr r3, =MaskDisIRQs+MaskSysMode
msr cpsr, r3 @ switch to sys mode

@ mark Undefined Instruction
ldr r1,=ExecType
mov r0, #Ex_IIns
str r0,[r1]

b  ReleaseHandler

DataAbortHandler:
@@ Save context from all modes, starting from Abort mode
str r0, [sp, #-4]!
ldr r0,=CurContext
stm r0,{r0-r12}

@DUMP
@ldr r1,=ControllerBaseAddress
@ldr r1,[r1]
@ldr r1,[r1,#0x20C] @FIQ control
@str r1,[r0,#10*4] @ show FIQ as r10 -> reports 0x89
@str r1,[r0,#9*4] @ show FIQ as r9

ldr r1, [sp], #4
str r1, [r0]		@ write program r0 in its place in CurContext
sub r1, lr, #8
str r1, [r0, #60] 	@ write program pc in its place (it is lr[-8] while in exception)
add r2, r0, #OffFPRegs
vstm r2!, {s0-s31} @ write floating-point regs
vmrs r3, FPSCR
str r3, [r2] @ write FPSCR
str sp, [r0, #OffAbtRegs] @ write abort sp
str lr, [r0, #OffAbtRegs+4] @ write abort lr
mrs r3, spsr
mov r4,#MaskDisIRQs
str r3, [r0, #OffAbtRegs+8] @ write abort SPSR
str r3, [r0, #OffCpsr] @ write program CPSR (copied to SPSR when accessing excep)
orr r3,r4,#MaskSysMode			@ Disable interrupts and imprecise aborts
msr cpsr, r3 @ switch to system mode to access remaining user regs
str sp, [r0, #52] @ write program sp in its place
str lr, [r0, #56] @ write program lr in its place
bic r3, r3, #0x4
msr cpsr, r3 @ switch from System to Undefined mode
str sp, [r0, #OffUndRegs] @ write undefined sp
str lr, [r0, #OffUndRegs+4] @ write undefined lr
mrs r2, spsr
str r2, [r0, #OffUndRegs+8] @ write undefined SPSR in its place
orr r3,r4,#MaskIrqMode
msr cpsr, r3 @ switch from Und to IRQ mode
mrs r2, spsr
str r2, [r0, #OffIrqRegs+8] @ write IRQ SPSR in its place
str sp, [r0, #OffIrqRegs] @ write IRQ sp
str lr, [r0, #OffIrqRegs+4] @ write IRQ lr
orr r3,r4,#MaskSvcMode
msr cpsr, r3 @ switch from IRQ to Supervisor mode
mrs r2, spsr
str r2, [r0, #OffSvcRegs+8] @ write supervisor SPSR in its place
str sp, [r0, #OffSvcRegs] @ write supervisor sp
str lr, [r0, #OffSvcRegs+4] @ write supervisor lr
orr r3,r4,#MaskFiqMode
msr cpsr, r3 @ switch to FIQ mode
mrs r2, spsr
str r2, [r0, #OffFiqRegs+28] @ write FIQ SPSR in its place
add r2, r0, #OffFiqRegs
stm r2, {r8-r14} @ write FIQ specific regs
orr r3,r4,#MaskSysMode
msr cpsr, r3 @ switch to sys mode

@ check if data abort is due to paging error
mrc p15, 0, r0, cr5, cr0, 0	@ Fault status register
mov r1, #0x400
orr r1, r1, #0xF                @ Mask for fault status
and r0, r0, r1
cmp r0, #0x7
bne mDAb			@ If fault!=0b0111, mark as data abort
mrc p15, 0, r0, cr6, cr0, 0	@ Conflict address
mov r1, r0
swi OS_ValidateAddress
bcs mDAb			@ If C flag active, address is outside valid range
ldr r0, =PrefetchAddress	@ If valid address, store it to prefetch in
str r1, [r0]			@ the next loop,
b ReleaseHandler		@ and do not mark data abort

@ mark Data Abort
mDAb:
ldr r1,=ExecType
mov r0, #Ex_DAb
str r0,[r1]

b ReleaseHandler

IRQHandler:
@@ Save context from all modes, starting from IRQ mode
stmdb sp!, {r0-r4, r12}
sub r0, lr, #4		@ get program pc to call function (it is lr while in exception)
mov r4, r0		@ also keep it in a safe register
bl validMemAddressRange
cmp r0, #0
addeq sp,sp,#24
beq IRQH_CheckIRQ	@ if PC non-valid, do not store current context
ldr r0,=CurContext
stm r0,{r0-r12}
str r4, [r0, #60] 	@ write program pc in its place
ldmia sp!, {r1-r5, r6}
stm r0, {r1-r5}		@ write program r0-r4 in their place in CurContext
str r6, [r0, #48]	@ write program r12 (ip) in its place
add r2, r0, #OffFPRegs
vstm r2!, {s0-s31} @ write floating-point regs
vmrs r3, FPSCR
str r3, [r2] @ write FPSCR
mrs r3, spsr
str r3, [r0, #OffIrqRegs+8] @ write IRQ SPSR in its place
str sp, [r0, #OffIrqRegs] @ write IRQ sp
str lr, [r0, #OffIrqRegs+4] @ write IRQ lr
orr r3, r3, #MaskDisIRQs	@ Disable interrupts and imprecise aborts
orr r3, r3, #MaskSysMode
msr cpsr, r3 @ switch to system mode to access remaining user regs
str sp, [r0, #52] @ write program sp in its place
str lr, [r0, #56] @ write program lr in its place
bic r3, r3, #0x4
msr cpsr, r3 @ switch from System to Undefined mode
str sp, [r0, #OffUndRegs] @ write undefined sp
str lr, [r0, #OffUndRegs+4] @ write undefined lr
mrs r2, spsr
str r2, [r0, #OffUndRegs+8] @ write undefined SPSR in its place
bic r3, r3, #0x8
msr cpsr, r3 @ switch from undefined to Supervisor mode
mrs r2, spsr
str r2, [r0, #OffSvcRegs+8] @ write supervisor SPSR in its place
str sp, [r0, #OffSvcRegs] @ write supervisor sp
str lr, [r0, #OffSvcRegs+4] @ write supervisor lr
orr r3, r3, #0x4
msr cpsr, r3 @ switch from supervisor to Abort mode
mrs r2, spsr
str sp, [r0, #OffAbtRegs] @ write abort sp
str lr, [r0, #OffAbtRegs+4] @ write abort lr
str r2, [r0, #OffAbtRegs+8] @ write abort SPSR
bic r3, r3, #0x6
msr cpsr, r3 @ switch from Abort to FIQ mode
mrs r2, spsr
str r2, [r0, #OffFiqRegs+7*4] @ write FIQ SPSR in its place
add r2, r0, #OffFiqRegs
stm r2, {r8-r14} @ write FIQ specific regs
IRQH_CheckIRQ:
mrs r3, cpsr
orr r3, r3, #MaskDisIRQs	@ Disable interrupts and imprecise aborts
orr r3, r3, #MaskSysMode
msr cpsr, r3 		@ switch to sys mode
@ Check if entry has an associated driver in the table
ldr r0, =drivercount
ldr r0, [r0]
ldr r1, =drivertable
add r1, r0, LSL #2	@ get past last element in driver table (base + offset of
add r1, r0, LSL #3	@ num drivers * 12 bytes per entry)

IRQH_while:
cmp r0, #0
beq ReleaseHandler	@ none of the devices in the table provoked the interrupt,
			@ let RISC OS handle it
sub r0, r0, #1
ldr r2, [r1, #-12]!	@ get number of device from driver table
rsb r4, r2, #64         @ get (64-dev) to perform translation to bit position
		@ (consider that for IRQ 1 & 2, bit position has to be below 32)
cmp r2, #32		@ check if it is IRQ 1 (<32) or 2 (>32)
mov r3, #1
ror r4, r3, r4           @ translate number of device into bit position
ldr r3, =ControllerBaseAddress
ldr r3,[r3]
ldrlt r3, [r3, #0x204]	@ if dev < 32, get pending IRQs 1
ldrge r3, [r3, #0x208]	@ if dev >= 32, get pending IRQs 2
tst r4, r3
beq IRQH_while

IRQH_attend:
@ Attend the interrupt: make Dbgr jump to user driver
ldr r0, =CurContext
ldr r6, =IRQregBkup
ldm r0, {r2-r5}
stmia r6!, {r2-r5}		@ bkup of user temp regs (r0-r3)
ldr r2, [r0, #48]
str r2, [r6], #4 		@ plus r12
ldr r2, [r0, #60]
str r2, [r6]     		@ and current user PC
ldr r2, [r1, #4]		@ get driver address
str r2, [r0, #60]		@ and store it in user PC
ldr r2, [r1, #8]		@ get R12 value for driver
str r2, [r0, #48]		@ and store it in user R12 reg
ldr r1, [r0, #OffCpsr]		@ get user CPSR
str r1, [r0, #OffIrqRegs+8]	@ store previous CPSR in IRQ SPSR
bic r1, r1, #MaskSysMode	@ clear current user mode
orr r1, r1, #MaskIrqMode	@ update user CPSR to IRQ mode
orr r1, r1, #MaskDisIRQs	@ disable IRQs
str r1, [r0, #OffCpsr]
ldr r1, =IRQFinishHandler	@ store return @ (function to get back to prev mode)
str r1, [r0, #OffIrqRegs+4]	@ in IRQ lr
b ReleaseHandler

@
@ User routine has finished attending an interrupt, get user back to its previous
@ context.
@
IRQFinishHandler:
mrs r2, cpsr
ands r1, r2, #0xF
swieq 0x16			@ if in user mode, switch to SVC
orr r2, r2, #MaskDisIRQs	@ disable IRQs
orr r2, r2, #MaskSysMode
msr cpsr, r2			@ switch to SYS mode
@@ Save context from all modes, starting from SYS mode
ldr r0, =CurContext
add r1, r0, #16                 @ write program r4-r14 in CurContext (remember
stm r1, {r4-r14}		@ that r0-r3 & r12 are restored later from bkup)
add r1, r0, #OffFPRegs
vstm r1!, {s0-s31} 		@ write floating-point regs
vmrs r3, FPSCR
str r3, [r1] 			@ write FPSCR
bic r2, r2, #0xD		@ switch from SYS to IRQ
msr cpsr, r2
mrs r3, spsr
str r3, [r0, #OffIrqRegs+8]	@ write IRQ SPSR in its place
str sp, [r0, #OffIrqRegs]	@ write IRQ sp
str lr, [r0, #OffIrqRegs+4]	@ write IRQ lr
orr r2, r2, #0x9		@ switch from IRQ to Undefined mode
msr cpsr, r2
str sp, [r0, #OffUndRegs]	@ write undefined sp
str lr, [r0, #OffUndRegs+4]	@ write undefined lr
mrs r3, spsr
str r3, [r0, #OffUndRegs+8]	@ write undefined SPSR in its place
bic r2, r2, #0x8
msr cpsr, r2 			@ switch from undefined to Supervisor mode
mrs r3, spsr
str r3, [r0, #OffSvcRegs+8]	@ write supervisor SPSR in its place
str sp, [r0, #OffSvcRegs]	@ write supervisor sp
str lr, [r0, #OffSvcRegs+4]	@ write supervisor lr
orr r2, r2, #0x4
msr cpsr, r2 			@ switch from supervisor to Abort mode
mrs r3, spsr
str sp, [r0, #OffAbtRegs]	@ write abort sp
str lr, [r0, #OffAbtRegs+4] 	@ write abort lr
str r3, [r0, #OffAbtRegs+8]	@ write abort SPSR
bic r2, r2, #0x6
msr cpsr, r2			@ switch from Abort to FIQ mode
mrs r3, spsr
str r3, [r0, #OffFiqRegs+28]	@ write FIQ SPSR in its place
add r3, r0, #OffFiqRegs
stm r3, {r8-r14} 		@ write FIQ specific regs
orr r2, r2, #MaskSysMode	@ switch back to SYS mode
msr cpsr, r2

ldr r1, =IRQregBkup
ldmia r1!, {r2-r5}
stm r0, {r2-r5}			@ restore bkup of user temp regs (r0-r3)
ldr r2, [r1], #4 		@ plus r12
str r2, [r0, #48]
ldr r2, [r1]     		@ and current user PC
str r2, [r0, #60]
ldr r1, [r0, #OffIrqRegs+8]	@ get SPSR from user IRQ mode
str r1, [r0, #OffCpsr]		@ and restore it in user CPSR
b ReleaseHandler


ReleaseHandler:
ldr r0,=ourregisters
mrs r1, CPSR
orr r1,r1,#0xF
bic r1, r1, #0xC
orr r1, r1, #MaskDisIRQs	@ disable IRQ
msr CPSR, r1       @ switch from Sys to SVC
ldr sp, [r0, #OffSvcRegs]	@ load debugger SVC sp
ldr lr, [r0, #OffSvcRegs+4]	@ load debugger SVC lr
ldr r2, [r0, #OffSvcRegs+8]
msr spsr, r2       @ load debugger SVC spsr
bic r1, r1, #0x1
msr cpsr, r1 @ switch from SVC to IRQ mode
ldr sp, [r0, #OffIrqRegs]	@ load IRQ sp
ldr lr, [r0, #OffIrqRegs+4]	@ load IRQ lr
ldr r2, [r0, #OffIrqRegs+8]
msr spsr, r2       @ load IRQ SPSR
orr r1, r1, #0x5
msr cpsr, r1 @ switch from IRQ to Abt mode
ldr sp, [r0, #OffAbtRegs]	@ load abort sp
ldr lr, [r0, #OffAbtRegs+4]	@ load abort lr
ldr r2, [r0, #OffAbtRegs+8]
msr spsr, r2       @ load abort SPSR
bic r1, r1, #0x6
msr cpsr, r1 @ switch from Abt to FIQ mode
add r2, r0, #OffFiqRegs
ldm r2, {r8-r14}   @ load FIQ specific regs
ldr r2, [r0, #OffFiqRegs+28]
msr spsr, r2       @ load FIQ SPSR
orr r1, r1, #0xA
msr cpsr, r1 @ switch from FIQ to Und mode
ldr sp, [r0, #OffUndRegs]	@ load undefined sp
ldr lr, [r0, #OffUndRegs+4]	@ load undefined lr
ldr r2, [r0, #OffUndRegs+8]
msr spsr, r2       @ load undefined SPSR
orr r1, r1, #MaskSysMode
msr cpsr, r1 @ switch to Sys mode
ldm r0, {r0-r14}  @ recover general purpose regs (previous usr mode is unknown)

@
@ write disable and enable IRQ regs to restore interrupts from GUI
@
mvn r1, #0			@ Load all bits to 1
mov r2, r1
bic r2, r2, #0x10000		@ Do NOT disable mouse
mov r3, r1
ldr r4, =ControllerBaseAddress
ldr r4, [r4]
add r5, r4, #0x21C
str r1, [r5], #4                @ Disable all interrupts
str r2, [r5], #4		@ one by one (a stm produces weird
str r3, [r5], #4		@ effects)
ldr r0, =DbgControllerMask
ldm r0, {r1-r3}
add r5, r4, #0x210
str r1, [r5], #4                @ Enable those interrupts used by the GUI
str r2, [r5], #4		@ one by one (a stm produces weird
str r3, [r5], #4		@ effects)
add r5,r4,#0x20C @FIQ control
ldr r0,[r5]
orr r0,r0,#0x80 @Enable fiq
str r0,[r5]

ldr r0,=HandDatRel
ldr r1,[r0]
mov r0,#0x4 @ release + data abort
ldr r2,=DataAbortHandler
swi OS_ClaimProcessorVector

ldr r0,=HandUndRel
ldr r1,[r0]
mov r0,#0x1 @ release + UNdefined instruction
ldr r2,=UndefinedInstructHandler
swi OS_ClaimProcessorVector

ldr r0,=HandPreRel
ldr r1,[r0]
mov r0,#0x3 @ release + prefetch abort
ldr r2,=PrefetchAbortHandler
swi OS_ClaimProcessorVector

ldr r0,=HandIRQRel
ldr r1,[r0]
mov r0,#0x6 @ release + IRQ
ldr r2,=IRQHandler
swi OS_ClaimProcessorVector

ldr r0,=ReturnHandler
ldr lr,[r0]
ldr r0,=StackHandler
ldr sp,[r0]

mrs r0,cpsr
bic r0,r0,#0x1C0	@ Re-enable imprecise aborts, fast interrupts,
msr cpsr,r0		@ and normal interrupts

mov pc, lr	@ Return in sys mode

.end

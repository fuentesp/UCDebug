/*
 * !UCDebug, ARM debugger for RISC OS.
 * https://github.com/fuentesp/UCDebug
 * Copyright (C) 2018  University of Cantabria
 *
 * !UCDebug was developed by the Computer Architecture and Technology
 * Group at the University of Cantabria. A comprehensive list of authors
 * can be found in the file AUTHORS.txt.
 *
 * You can reach the main developers at {fernando.vallejo, cristobal.camarero,
 * pablo.fuentes}@unican.es.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "oslib/wimp.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "Interpreter.h"
#include "ConsWin.h" /* To have access to the definition of UsrWinCreate function */
#include "main.h" /* To use general vars */

/* List of commands */
#define LOAD_CMD "ld"
#define RUN_CMD "go"
#define RUN_TO_CMD "gt"
#define RUN_FAST_CMD "gf"
#define TRACE_CMD "tr"
#define BRKPT_CMD "br"
#define CLR_BRKPT_CMD "clr"
#define STOP_CMD "stop"
#define SET_CMD "set"
#define MEM_CMD "mem"
#define CODE_CMD "code"
#define HELP_CMD "help"
#define QUIT_CMD "quit"
#define ABOUT_CMD "about"

#define ELF_FILE_BEG 0x464C457F
#define ASSIGN_DELIMITER '='

/* Message strings */
#define UNKNOWN_CMD_MSG		"Unrecognised command"
#define MISSING_ARGS_MSG	"Missing arguments! "
#define LOAD_ARGS_MSG		"(Usage: ld <file_name>)"
#define NOT_ELF_MSG			"File is not an ELF executable"
#define MIS_LINKED_MSG		"File is not properly linked to address"
#define FILE_TOO_BIG_MSG	"File exceeds maximum size allowed"
#define MIS_ADDR_MSG		"Missing address parameter"
#define INV_ADDR_MSG		"Out-of-range address"
#define UNALIGN_ADDR_MSG	"Address is not aligned to word"
#define UNALIGN_WORD_MSG	"Address 0x%08X is not aligned to store word 0x%08X"
#define UNALIGN_HALF_MSG	"Address 0x%08X is not aligned to store half 0x%04X"
#define INVALID_MEM_SIZE	"Size %d is not a valid size: 8(byte) / 16(half) / 32(word)"
#define BREAKPOINT_MSG		"Reached user breakpoint at addr 0x%08X"
#define GT_BRKPT_MSG		"Reached temp breakpoint at addr 0x%08X"
#define CLRD_BRK_MSG		"Cleared all breakpoints"
#define DAT_AB_MSG			"Data Abort at addr 0x%08X"
#define PR_AB_MSG			"Prefetch Abort at addr 0x%08X"
#define IL_INS_MSG			"Illegal Instruction at addr 0x%08X"
#define PRG_END_MSG			"Program execution has finished"

/* Local functions */
void runCode();
void HandleSWI();
void HandleException();

void interpreter(char *linea) {
	/* Allocate memory for the string array with the commands */
	const char s[] = " ";
	int nargs = 0;
	char *token, *aux = strdup(linea);
	token = strtok(aux, s);
	while (token != NULL) {
		nargs++;
		token = strtok(NULL, s);
	}

	/* If no commands are provided, return */
	if (nargs == 0) return;

	/* Split the line in command and arguments */
	char *args[nargs];
	int i = 0, addr;
	char aux_msg[ConsLinSize];
	unsigned int size, val;
	aux = strdup(linea);
	args[i] = strtok(aux, s);

	while (args[i] != NULL) {
		i++;
		args[i] = strtok(NULL, s);
	}

	/* Check the command */
	if (strcmp(args[0], LOAD_CMD) == 0) {
		if (nargs < 2) {
			strncpy(aux_msg, MISSING_ARGS_MSG, ConsLinSize);
			strncat(aux_msg, LOAD_ARGS_MSG, sizeof(aux_msg) - sizeof(MISSING_ARGS_MSG));
			ConsWrite(ConsWin, aux_msg);
		} else {
			loadFile(args[1]);
		}
	} else if (strcmp(args[0], RUN_CMD) == 0) {
		if (nargs > 1) { /* Start executing the code from a given address */
			addr = getAddr(args[1]);
			if (!validMemAddressRange(addr)) {
				ConsWrite(ConsWin, INV_ADDR_MSG);
				return;
			} else if (!alignedAddr(addr)) {
				ConsWrite(ConsWin, UNALIGN_ADDR_MSG);
				return;
			} else {
				CurContext.Regs[15] = addr;
			}
		}
		/* If no address is given, start executing the code from the default initial
		 * address */
		ExecType = Run_Go;
		runCode();
	} else if (strcmp(args[0], RUN_FAST_CMD) == 0) {
		if (nargs > 1) { /* Start executing the code from a given address; if no address
		 is given, start executing the code from the default initial address */
			addr = getAddr(args[1]);
			if (!validMemAddressRange(addr)) {
				ConsWrite(ConsWin, INV_ADDR_MSG);
				return;
			} else if (!alignedAddr(addr)) {
				ConsWrite(ConsWin, UNALIGN_ADDR_MSG);
				return;
			} else {
				CurContext.Regs[15] = addr;
			}
		}
		/* Avoid stopping at the breakpoints */
		ExecType = Run_Gd;
		runCode();
	} else if (strcmp(args[0], TRACE_CMD) == 0) {
		/* Trace mode: only execute one instruction */
		ExecType = Run_Tr;
		runCode();
	} else if (strcmp(args[0], RUN_TO_CMD) == 0) {
		/* Start executing ignoring breakpoints until specified address is reached */
		if (nargs == 1) {
			ConsWrite(ConsWin, MIS_ADDR_MSG);
			return;
		}
		addr = getAddr(args[1]);
		if (!validMemAddressRange(addr)) {
			ConsWrite(ConsWin, INV_ADDR_MSG);
			return;
		} else if (!alignedAddr(addr)) {
			ConsWrite(ConsWin, UNALIGN_ADDR_MSG);
			return;
		}
		GTBrkP = addr;
		/* Avoid stopping at the breakpoints */
		ExecType = Run_Gt;
		runCode();
	} else if (strcmp(args[0], STOP_CMD) == 0) {
		/* Stop execution */
		ExecType = Stop_Ex;
		ConsWrite(ConsWin, "Stopping exec");
	} else if (strcmp(args[0], BRKPT_CMD) == 0) {
		if (nargs == 1) {
			/* Print breakpoint list */
			PrintBrk();
		} else {
			/* Toggle breakpoint */
			addr = getAddr(args[1]);
			if (!validMemAddressRange(addr))
				ConsWrite(ConsWin, INV_ADDR_MSG);
			else if (!alignedAddr(addr))
				ConsWrite(ConsWin, UNALIGN_ADDR_MSG);
			else
				ToggleBrk(addr);
			CodeWinRedraw(CodeWin, AddrCodeCur, NumLinCode);
		}
	} else if (strcmp(args[0], CLR_BRKPT_CMD) == 0) {
		ClrBrk();
		ConsWrite(ConsWin, CLRD_BRK_MSG);
		CodeWinRedraw(CodeWin, AddrCodeCur, NumLinCode);
	} else if (strcmp(args[0], MEM_CMD) == 0) {
		if (nargs == 1) { /* Reset memory view */
			resetMemView();
		} else if (nargs == 2) {
			/* Reset memory view, starting from specified address */
			addr = getAddr(args[1]);
			if (!validMemAddressRange(addr))
				ConsWrite(ConsWin, INV_ADDR_MSG);
			else if (!alignedAddr(addr))
				ConsWrite(ConsWin, UNALIGN_ADDR_MSG);
			else
				setMemView(addr);
		}
	} else if (strcmp(args[0], SET_CMD) == 0) {
		size = 32;
		for (i = 1; i < nargs; i++) {
			if (strchr(args[i], ASSIGN_DELIMITER) == NULL) {
				size = getVal(args[i]);
				continue;
			} else {
				addr = getAddr(strtok(args[i], (char *) ASSIGN_DELIMITER));
				if (!validMemAddressRange(addr)) {
					ConsWrite(ConsWin, INV_ADDR_MSG);
					continue;
				}
				val = getVal(strchr(args[i], ASSIGN_DELIMITER) + 1);
				setMem(addr, val, size);
			}
		}
		setMemView(AddrDataCur);
		setCodeView(AddrCodeCur);
	} else if (strcmp(args[0], CODE_CMD) == 0) {
		if (nargs == 1) { /* Reset code view */
			resetCodeView();
		} else {
			addr = getAddr(args[1]);
			if (!validMemAddressRange(addr))
				ConsWrite(ConsWin, INV_ADDR_MSG);
			else if (!alignedAddr(addr))
				ConsWrite(ConsWin, UNALIGN_ADDR_MSG);
			else
				setCodeView(addr);
		}
	} else if (strcmp(args[0], HELP_CMD) == 0) {
		help();
	} else if (strcmp(args[0], QUIT_CMD) == 0) {
		/* Exit the debugger */
		mainQuitFlag = TRUE;
	} else if (strcmp(args[0], ABOUT_CMD) == 0) {
		printAuthors();
	} else {
		/* Command not recognized */
		ConsWrite(ConsWin, UNKNOWN_CMD_MSG);
	}
}

void help() {
	char help_msg[ConsLinSize];
	ConsWrite(ConsWin, "List of commands:");
	strncpy(help_msg, ABOUT_CMD, ConsLinSize);
	strncat(help_msg, "                        prints the list of authors of the debugger",
			sizeof(help_msg) - sizeof(ABOUT_CMD));
	strncpy(help_msg, LOAD_CMD, ConsLinSize);
	strncat(help_msg, " file_name           load the assembly file onto the debugger",
			sizeof(help_msg) - sizeof(LOAD_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, TRACE_CMD, sizeof(help_msg));
	strncat(help_msg, "                     execute a single instruction",
			sizeof(help_msg) - sizeof(TRACE_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, RUN_CMD, sizeof(help_msg));
	strncat(help_msg, "                     execute from the first instruction",
			sizeof(help_msg) - sizeof(RUN_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, RUN_CMD, sizeof(help_msg));
	strncat(help_msg, " <addr>              execute from the instruction in <addr>",
			sizeof(help_msg) - sizeof(RUN_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, RUN_FAST_CMD, sizeof(help_msg));
	strncat(help_msg, "                     execute from the first instruction",
			sizeof(help_msg) - sizeof(RUN_CMD) - 1);
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, "                       without stopping at the breakpoints",
			sizeof(help_msg));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, RUN_FAST_CMD, sizeof(help_msg));
	strncat(help_msg, " <addr>              execute from the instruction in <addr>",
			sizeof(help_msg) - sizeof(RUN_CMD) - 1);
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, "                       without stopping at the breakpoints",
			sizeof(help_msg));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, RUN_TO_CMD, sizeof(help_msg));
	strncat(help_msg, " ", sizeof(help_msg) - sizeof(RUN_CMD));
	strncat(help_msg, " <addr>             execute without stopping at breakpoints",
			sizeof(help_msg) - sizeof(RUN_CMD) - 1);
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, "                       until <addr> is reached", sizeof(help_msg));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, BRKPT_CMD, sizeof(help_msg));
	strncat(help_msg, "                     list the breakpoints currently set",
			sizeof(help_msg) - sizeof(BRKPT_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, BRKPT_CMD, sizeof(help_msg));
	strncat(help_msg, " <addr>              toggle a breakpoint at <addr>",
			sizeof(help_msg) - sizeof(BRKPT_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, CLR_BRKPT_CMD, sizeof(help_msg));
	strncat(help_msg, "                    clear all breakpoints",
			sizeof(help_msg) - sizeof(CLR_BRKPT_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, STOP_CMD, sizeof(help_msg));
	strncat(help_msg, "                   stop the execution",
			sizeof(help_msg) - sizeof(STOP_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, SET_CMD, sizeof(help_msg));
	strncat(help_msg, " [<s>] <addr>=<val> replace <s> bytes of memory content",
			sizeof(help_msg) - sizeof(MEM_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, "                       (default=32bits) at <addr> with <val>",
			sizeof(help_msg));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, MEM_CMD, sizeof(help_msg));
	strncat(help_msg, "                    reset the memory view window",
			sizeof(help_msg) - sizeof(MEM_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, MEM_CMD, sizeof(help_msg));
	strncat(help_msg, " <addr>             reset the memory view window, starting",
			sizeof(help_msg) - sizeof(MEM_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, "                       from <addr>", sizeof(help_msg));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, CODE_CMD, sizeof(help_msg));
	strncat(help_msg, "                   reset the code view window",
			sizeof(help_msg) - sizeof(CODE_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, CODE_CMD, sizeof(help_msg));
	strncat(help_msg, " <addr>            reset the code view window, starting from",
			sizeof(help_msg) - sizeof(CODE_CMD));
	ConsWrite(ConsWin, help_msg);
	strncpy(help_msg, "                       <addr>", sizeof(help_msg));
	ConsWrite(ConsWin, help_msg);
}

void printAuthors() {
	char *msg;
	msg = malloc(ConsLinSize);
	strncpy(msg, "!UCDebug, ARM debugger for RISC OS.", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "https://github.com/fuentesp/UCDebug", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "Copyright (C) 2018 University of Cantabria", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "This debugger has been developed by the Computer Architecture", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "and Technology Group - Grupo de Arquitectura y Tecnología de", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "Computadores (ATC), at the University of Cantabria.", ConsLinSize);
	ConsWrite(ConsWin, msg);
	ConsWrite(ConsWin, "");
	strncpy(msg, "Main Developers:", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "-Cristóbal Camarero Coterillo", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "-Fernando Vallejo Alonso", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "-Pablo Fuentes Sáez", ConsLinSize);
	ConsWrite(ConsWin, msg);
	ConsWrite(ConsWin, "");
	strncpy(msg, "Contributors:", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "-Carmen Martínez Fernández, head of the project that has led to", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "the development of this debugger.", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "-Jesús Gutiérrez Preciado, Elena Zaira Suárez Santamaría and", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "Adrián Barredo Ferreira, prior work with RISC OS and the", ConsLinSize);
	ConsWrite(ConsWin, msg);
	strncpy(msg, "Raspberry Pi.", ConsLinSize);
	ConsWrite(ConsWin, msg);
	free(msg);
}

/* loadFile loads a given file in the reserved debugging area in memory */
void loadFile(char *filename) {
	FILE *file = fopen(filename, "rb");
	long flength;
	char aux_msg[ConsLinSize];

	if (file) {
		/* Check if file is an ELF */
		int elfSize = 0, prHeadSize = 0;
		char auxBuf[4];
		fread(auxBuf, 1, 4, file);
		if (*(int *) &auxBuf != ELF_FILE_BEG) {
			strncpy(aux_msg, NOT_ELF_MSG, sizeof(aux_msg));
			ConsWrite(ConsWin, aux_msg);
		} else {
			/*Check if link addresses are correct */
			fseek(file, OffElfHeadSize, SEEK_SET);
			fread(&elfSize, 1, 2, file);
			fread(&prHeadSize, 1, 2, file);
			fseek(file, elfSize + OffVirtAddr, SEEK_SET);
			fread(auxBuf, 1, 4, file);
			if (*(int *) &auxBuf != AddrElfFile) {
				sprintf(aux_msg, "%s 0x%08X", MIS_LINKED_MSG, AddrElfFile);
				ConsWrite(ConsWin, aux_msg);
			} else {
				/* Check if ELF file fits in debugging area */
				fseek(file, 0, SEEK_END);
				flength = ftell(file);
				fseek(file, 0, SEEK_SET);
				if (flength > ((int) &CurContext - AddrElfFile)) {
					sprintf(aux_msg, "%s (max %d bytes)", FILE_TOO_BIG_MSG,
							DebugAreaSize);
				} else {
					/* Load ELF file and update data and code windows */
					fread((char *) (AddrElfFile), 1, flength, file);
					fseek(file, OffEntryPoint, SEEK_SET);
					fread(&AddrCodeStart, 1, 4, file);
					CurContext.Regs[15] = AddrCodeStart; /* PC = entry point */
					CurContext.Regs[13] = 0x00019000; /* Stack pointer provisional */
					fseek(file, elfSize + prHeadSize + OffVirtAddr, SEEK_SET);
					fread(&AddrDataStart, 1, 4, file);
					fclose(file);
					resetCodeView();
					resetMemView();
					RegsWinRedraw(RegsWin);
					strncpy(aux_msg, "\"", sizeof(aux_msg));
					strncat(aux_msg, filename, sizeof(aux_msg) - 1);
					strncat(aux_msg, "\" loaded successfully",
							sizeof(aux_msg) - sizeof(filename) - 1);
				}
			}
		}
	} else {
		strncpy(aux_msg, "ERROR: file \"", sizeof(aux_msg));
		strncat(aux_msg, filename, sizeof(aux_msg) - 13);
		strncat(aux_msg, "\" not found", sizeof(aux_msg) - sizeof(filename) - 13);
		ConsWrite(ConsWin, aux_msg);
	}
}

/* resetMemView resets the Memory view window to start at the initial address */
void resetMemView() {
	AddrDataCur = AddrDataStart;
	memDispType = 0; /* Reset memory view to words */
	DataWinRedraw(DataWin, AddrDataCur, NumLinData, memDispType);
}

/* setMemView sets the Memory view window to start displaying the memory from a given
 * address */
void setMemView(int startDir) {
	AddrDataCur = startDir;
	DataWinRedraw(DataWin, AddrDataCur, NumLinData, memDispType);
}

/* resetCodeView resets the Code view window to start at the initial address */
void resetCodeView() {
	AddrCodeCur = AddrCodeStart;
	CodeWinRedraw(CodeWin, AddrCodeCur, NumLinCode);
}

/* setCodeView sets the Code view window to start displaying the memory from a given
 * address */
void setCodeView(int startDir) {
	AddrCodeCur = startDir;
	CodeWinRedraw(CodeWin, AddrCodeCur, NumLinCode);
}

/* getAddr extracts a memory address from a string (typically input by the user). If the
 * address notation is not specifically hex or octal, it treats the value as hex (because
 * it is an address) */
int getAddr(char *str) {
	int addr = -1;

	if (strncmp(str, "0", 1) != 0) {
		addr = strtol(str, NULL, 16);
	} else {
		addr = strtol(str, NULL, 0);
	}
	return addr;
}

/* getVal converts a string into a long integer */
unsigned int getVal(char *str) {
	return strtoul(str, NULL, 0);
}

/* setMem assigns a value to a given memory address, following a specific size */
void setMem(int addr, int val, int size) {
	char auxMsg[ConsLinSize];
	/* Check if the value is a byte, a half, or a word, and
	 ensure the address is properly aligned */
	switch (size) {
		case 8: /* Byte */
			*(char *) addr = (char) val;
			break;
		case 16: /* Half */
			if (addr % 2 != 0) {
				snprintf(auxMsg, sizeof(auxMsg), UNALIGN_HALF_MSG, addr, val);
				ConsWrite(ConsWin, auxMsg);
			} else {
				*(char *) addr = (char) (val & 0xFF);
				*(char *) (addr + 1) = (char) ((val >> 8) & 0xFF);
			}
			break;
		case 32: /* Word */
			if (addr % 4 != 0) {
				snprintf(auxMsg, sizeof(auxMsg), UNALIGN_WORD_MSG, addr, val);
				ConsWrite(ConsWin, auxMsg);
			} else {
				*(int *) addr = val;
			}
			break;
		default:
			snprintf(auxMsg, sizeof(auxMsg), INVALID_MEM_SIZE, size);
			ConsWrite(ConsWin, auxMsg);
	}
}

/* runCode calls the function that performs the execution of the next instruction(s) and
 * handles any exception that may arise. */
void runCode() {
	char aux_msg[ConsLinSize];

	SetPrompt(PromptRUN);
	while ((ExecType) != Stop_Ex) {
		mainPoll();
		CodeExecute();

		if ((ExecType & CmdByteMask) == Run_Tr) {
			/* If in trace mode, ensure the loop is exited */
			ExecType = ExecType & StateByteMask;
		}
		if ((ExecType & StateByteMask) == Stop_Ex) {
			continue; /* Normal exec, skip SWI and exception handling */
		}
		if ((ExecType & StateTypeMask) == 0x0000) {
			/* It is a SWI */
			HandleSWI();
		} else if ((ExecType & StateTypeMask) == 0x1000) {
			/* It is an exception */
			HandleException();
		}
	}
	SetPrompt(Prompt);
	DataWinRedraw(DataWin, AddrDataCur, NumLinData, memDispType);
	CodeWinRedraw(CodeWin, AddrCodeCur, NumLinCode);
	RegsWinRedraw(RegsWin);
	if (WindowStates[FPRegsWinOffset] != wss_CLOSED) FPRegsWinRedraw(FPRegsWin);
}

void HandleSWI() {
	char aux_msg[ConsLinSize];
	char* ptr;
	int i;
	switch (ExecType & SWI_Ex_Mask) {
		case Prg_End: /* End program */
			ConsWrite(ConsWin, PRG_END_MSG);
			ExecType = Stop_Ex; /* End the execution */
			break;
		case SWI_WrC: /* WriteChar */
			if (WindowStates[UsrWinOffset] == wss_CLOSED) {
				UsrWin = UsrWinCreate(PosXUsrWin, PosYUsrWin);
			}
			snprintf(aux_msg, sizeof(aux_msg), "%c", (char) CurContext.Regs[0]);
			UsrWrite(UsrWin, aux_msg);
			break;
		case SWI_WrL: /* WriteString */
			if (WindowStates[UsrWinOffset] == wss_CLOSED) {
				UsrWin = UsrWinCreate(PosXUsrWin, PosYUsrWin);
			}
			ptr = (char *) CurContext.Regs[0];
			UsrWrite(UsrWin, ptr);
			break;
		default:
			snprintf(aux_msg, sizeof(aux_msg),
					"ERROR! non-contemplated SWI at the interpreter: 0x%08X",
					ExecType & SWI_Ex_Mask);
			ConsWrite(ConsWin, aux_msg);
			break;
	}
	/* Check if next instruction will be executed (breakpoint, running mode...)
	 * and set the ExecType accordingly. */
	switch (ExecType & CmdByteMask) {
		case Run_Go:
			for (i = 0; i < CurNumBr; i++)
				if (CurContext.Regs[15] == BrkPtList[i]) {
					ExecType = Stop_Ex; /* Stop the execution */
					break;
				}
			break;
		case Run_Tr:
			ExecType = Stop_Ex; /* Stop the execution */
			break;
		case Run_Gt:
			if (CurContext.Regs[15] == GTBrkP)
				ExecType = Stop_Ex; /* Stop the execution */
			break;
	}
	ExecType = ExecType & CmdByteMask; /* Set state to normal exec */
}

void HandleException() {
	char aux_msg[ConsLinSize];

	switch (ExecType & StateByteMask) {
		case Stop_Br: /* Reached breakpoint */
			if ((ExecType & CmdByteMask) == Run_Gt)
				snprintf(aux_msg, sizeof(aux_msg), GT_BRKPT_MSG, GTBrkP);
			else
				snprintf(aux_msg, sizeof(aux_msg), BREAKPOINT_MSG, CurContext.Regs[15]);
			ConsWrite(ConsWin, aux_msg);
			break;
		case Ex_DAb: /* Data Abort */
			snprintf(aux_msg, sizeof(aux_msg), DAT_AB_MSG, CurContext.Regs[15]);
			ConsWrite(ConsWin, aux_msg);
			break;
		case Ex_IIns: /* Illegal Instruction */
			snprintf(aux_msg, sizeof(aux_msg), IL_INS_MSG, CurContext.Regs[15]);
			ConsWrite(ConsWin, aux_msg);
			break;
		case Ex_PAb: /* Prefetch Abort */
			snprintf(aux_msg, sizeof(aux_msg), PR_AB_MSG, CurContext.Regs[15]);
			ConsWrite(ConsWin, aux_msg);
			break;
		default:
			snprintf(aux_msg, sizeof(aux_msg),
					"ERROR!: non-contemplated exception at the interpreter");
			ConsWrite(ConsWin, aux_msg);
			break;
	}
	ExecType = Stop_Ex; /* If an exception occurs, execution is halted */
}

